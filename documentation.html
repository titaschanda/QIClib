<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Documentation - QIClib</title>
    <link rel="icon" href="qic.png" type="image/png">
    <meta name="author" content="Titas Chanda" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <meta name="robots" content="noindex">
    <meta name="googlebot" content="noindex">
  </head>
  <body>
    <section class="page-header">
      <img src="qic.png" alt="QIClib logo" style="width:80px;height:80px;">
      <h1 class="project-name">Quantum Information and Computation library <br> (QIClib)</h1>
      <h2 class="project-tagline">A C++11 library for quantum information and computation based on Armadillo</h2>

      <a href="index.html" class="btn">Home</a>
      <a href="documentation.html" class="btn">API Documentation</a>
      <a href="sample.html" class="btn">Sample Codes</a>
      <br>
      <a href="https://github.com/titaschanda/QIClib" class="btn">View on <br> GitHub</a>
      <a href="https://github.com/titaschanda/QIClib/archive/v1.0.0.zip" class="btn">Download .zip <br> v1.0.0</a>
      <a href="https://github.com/titaschanda/QIClib/archive/v1.0.0.tar.gz" class="btn">Download .tar.gz <br> v1.0.0</a>

    </section>

    <section class="main-content">
      <a name="top"></a>
      
      <!--<a name=top></a>-->  
      <center><h2> API Reference for QIClib 1.0
      </h2></center>

      
      <b>Preamble</b>
      <br>
      
      <tr>
	<td style="text-align: left; vertical-align: top; width: 50%;">
	  <ul>
	    <br>
	    <li>
	      Every functions, classes, or constants in QIClib belongs to the <code> namespace qic</code>.
	    </li>
	   
	    <li>
	      First time users may want to have a look on  <a href="sample.html#samples">sample programs</a>.
	    </li>
	   
	    <li>
	      First time users may want to have a look on  <a href="#faq">frequently asked questions</a>.
	    </li>
	   
	    <li>
	      If you discover any bugs or regressions, please <a href="index.html#found-an-issue-or-bug">report them</a>
	    </li>
	   
	    <li>
	      Notes on <a href="#api_additions">API additions</a>
	    </li>
	  </ul>
	</td>
	<td>

	  <br>


	  <b>Overview</b><br>
	  <ul>
	    <li><a href="#classes">Classes and constants</a></li>
	    <li><a href="#functions">Functions</a></li>
	    <li><a href="#discord_func">Classes for quantum discord like features</a></li>
	    <li><a href="#macro">Preprocessor macros to tune the library in compile time</a></li>
	  </ul>
	  <br>

	<a class="noprint" style="display:scroll; position:fixed; bottom:5px; right:5px;" href="#top"><font>[top]</font></a>


	  <a name="classes"></a>
	  <b>Classes and constants</b><br>
	  
	    <table>
	      <tbody>
		<!--		<tr><td><a href="#eps"> _precision::eps     </td><td>  </td><td> Precision for floating point arithmetic</td></tr>
		  -->		
		<tr><td><a href="#init"> Init     </td><td>  </td><td> Class for library initialization</td></tr>
		
		<tr><td><a href="#spm"> SPM&lt;POD_TYPE&gt;, spm, spmf</a>  </td><td>  </td><td> Several predefined constant special 
		    matrices like basis states, projectors and operators</td></tr>

  		<tr><td><a href="#gates"> GATES&lt;POD_TYPE&gt;, gates, gatesf</a>  </td><td>  </td><td> Several predefined 
  		    constant quantum gates and generators of quantum gate</td></tr>

		
		<tr><td><a href="#func"> Func&lt;POD_TYPE&gt;, func, funcf  </td><td>  </td><td> Several predefined functions to be 
		    used with <code><a href = #funcm_sym>funcm_sym</a></code> or <code><a href = #funcm_gen>funcm_gen</a></code>
		    
		</td></tr>
		<tr><td><a href="#RandomDevices"> RandomDevices, rdevs</td><td>  </td><td> Predefined random number 
		    engines/generators, used in functions like <a href="#randU">randU</a> etc.
		</td></tr>

		
	      </tbody>
	    </table>
	  
	  <br>



	  <a name="functions"></a>
	  <b>Functions</b><br>
	  
	    <table>
	      <tbody>
		<tr><td><a href="#is_Hermitian"> is_Hermitian </a> </td><td>  </td><td> Hermiticity check</td></tr>
		
		<tr><td><a href="#is_Unitary"> is_Unitary </a> </td><td>  </td><td> Unitarity check</td></tr>
		
		<tr><td><a href="#is_Normal"> is_Normal </a> </td><td>  </td><td> To check whether the the matrix is 
		    normal or not</td></tr>
		
		<tr><td><a href="#is_pure"> is_pure </a> </td><td>  </td><td> To check purity of a density matrix</td></tr>
		
		<tr><td><a href="#is_valid_state"> is_valid_state </a> </td><td>  </td><td>To check whether the matrix 
		    represents a valid quantum state</td></tr>

		<tr><td><a href="#is_diagonalizable"> is_diagonalizable </a> </td><td>  </td><td>To check whether the matrix 
		    is diagonalizable or not</td></tr>

		<tr><td><a href="#is_equal"> is_equal </a> </td><td>  </td><td>To check whether two matrices are equal</td></tr>

		<tr><td><a href="#dense_to_sparse"> dense_to_sparse </a> </td><td>  </td><td>To convert a dense matrix 
		    (<a href="http://arma.sourceforge.net/docs.html#Mat">Mat</a>) to a sparse 
		    (<a href="http://arma.sourceforge.net/docs.html#SpMat">SpMat</a>) matrix</td></tr>
		
		<tr><td><a href="#sparse_to_dense"> sparse_to_dense </a> </td><td>  </td><td>To convert a sparse matrix 
		    (<a href="http://arma.sourceforge.net/docs.html#SpMat">SpMat</a>) to a dense
		    (<a href="http://arma.sourceforge.net/docs.html#Mat">Mat</a>) 
		    matrix</td></tr>
		
		<tr><td><a href="#range"> range </a> </td><td>  </td><td> Similar to Python's range() function. 
		    Useful in range-based for loops</td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#TrX"> TrX </a> </td><td>  </td><td> Partial trace</td></tr>
		
		<tr><td><a href="#Tx"> Tx </a> </td><td>  </td><td> Partial transpose</td></tr>

		<tr><td><a href="#sysperm"> sysperm </a> </td><td>  </td><td> Permute subsystems of a quantum state</td></tr>
		
		<tr><td><a href="#sqrtm_sym"> sqrtm_sym </a> </td><td>  </td><td>Principal square root of 
		    real symmetric or Hermitian matrices</td></tr>

		<tr><td><a href="#sqrtm_gen"> sqrtm_gen </a> </td><td>  </td><td>Principal square root of general square matrices</td></tr>
		
		<tr><td><a href="#powm_sym"> powm_sym </a> </td><td>  </td><td>Matrix power for real symmetric 
		    or Hermitian matrices</td></tr>
		
		<tr><td><a href="#powm_gen"> powm_gen </a> </td><td>  </td><td>Matrix power for general square 
		    matrices</td></tr>
		
		<tr><td><a href="#expm_sym"> expm_sym </a> </td><td>  </td><td>Matrix exponential for real symmetric 
		    or Hermitian matrices</td></tr>
		
		<tr><td><a href="#expm_gen"> expm_gen </a> </td><td>  </td><td>Matrix exponential for general 
		    square matrices</td></tr>

		<tr><td><a href="#funcm_sym"> funcm_sym </a> </td><td>  </td><td>Matrix function for real symmetric 
		    or Hermitian matrices</td></tr>

		<tr><td><a href="#funcm_gen"> funcm_gen </a> </td><td>  </td><td>Matrix function for 
		    general square matrices</td></tr>

		<tr><td><a href="#tensor"> tensor </a> </td><td>  </td><td> Tensor product of 
		    arbitrary no. of matrices</td></tr>

		<tr><td><a href="#tensor_pow"> tensor_pow </a> </td><td>  </td><td>Tensor product power</td></tr>	
		
		<tr><td><a href="#dsum"> dsum </a> </td><td>  </td><td> Direct sum of arbitrary no. of  matrices</td></tr>
		
		<tr><td><a href="#dsum_pow"> dsum_pow </a> </td><td>  </td><td>Direct sum power</td></tr>		
		
		<tr><td><a href="#absm"> absm </a> </td><td>  </td><td>Matrix absolute value of a square matrix</td></tr>
		
		<tr><td><a href="#schatten"> schatten </a> </td><td>  </td><td>Schatten p-norm of a matrix</td></tr>
		
		<tr><td><a href="#purify"> purify </a> </td><td>  </td><td>Minimal purification of a density matrix</td></tr>
		
		<tr><td><a href="#gram_schmidt"> gram_schmidt </a> </td><td>  </td><td>Modified Gram-Schmidt orthogonalization</td></tr>
		
		<tr><td><a href="#conv_to_pure"> conv_to_pure </a> </td><td>  </td><td> To convert density matrix of a 
		    pure state to a column vector</td></tr>

		<tr><td><a href="#std_to_HS"> std_to_HS </a> </td><td>  </td><td> To convert 2-qubit density matrix 
		    from the standard basis to the Hilbert-Schmidt basis </td></tr>
		
		<tr><td><a href="#HS_to_std"> HS_to_std </a> </td><td>  </td><td>To convert 2-qubit density matrix from 
		    the Hilbert-Schmidt basis back to the standard basis</td></tr>
		
		<tr><td><a href="#mket"> mket </a> </td><td>  </td><td>To generate multipartite qudit pure state </td></tr>
		<tr><td><a href="#mproj"> mproj </a> </td><td>  </td><td>To genearte multipartite qudit projector </td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#randU"> randU </a> </td><td>  </td><td> To generate object with random values 
		    (uniform distribution)</td></tr>

		<tr><td><a href="#randN"> randN </a> </td><td>  </td><td> To generate object with random values 
		    (normal distribution)</td></tr>

		<tr><td><a href="#randI"> randI </a> </td><td>  </td><td> To generate object with random integers</td></tr>
		
		<tr><td><a href="#randHermitian"> randHermitian </a> </td><td>  </td><td> To generate random Hermitian 
		    matrix</td></tr>

		<tr><td><a href="#randUnitary"> randUnitary </a> </td><td>  </td><td> To generate random unitary matrix</td></tr>
		
		<tr><td><a href="#randPsi"> randPsi </a> </td><td>  </td><td> To generate random pure states</td></tr>
		
		<tr><td><a href="#randRho"> randRho </a> </td><td>  </td><td> To generate random mixed states</td></tr>

		<tr><td><a href="#randPerm"> randPerm </a> </td><td>  </td><td> To generate random permutation of unsigned integers</td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>



		<tr><td><a href="#entropy"> entropy </a> </td><td>  </td><td>von Neumann entropy of a quantum state</td></tr>
		
		<tr><td><a href="#shannon"> shannon </a> </td><td>  </td><td>Shannon entropy of a probability distribution</td></tr>

		<tr><td><a href="#renyi"> renyi </a> </td><td>  </td><td>Renyi entropy of a quantum state</td></tr>

		<tr><td><a href="#renyi_prob"> renyi_prob </a> </td><td>  </td><td>Renyi entropy of a probability 
		    distribution</td></tr>

		<tr><td><a href="#tsallis"> tsallis </a> </td><td>  </td><td>Tsallis entropy of a quantum state</td></tr>

		<tr><td><a href="#tsallis_prob"> tsallis_prob </a> </td><td>  </td><td>Tsallis entropy of a probability distribution</td></tr>

		<tr><td><a href="#mutual_info"> mutual_info </a> </td><td>  </td><td>Quantum mutual information between 2 
		    subsystems of a quantum state</td></tr>

		<tr><td><a href="#rel_entropy"> rel_entropy </a> </td><td>  </td><td> Relative entropy between two quantum states</td></tr>

		<tr><td><a href="#rel_entropy_prob"> rel_entropy_prob </a> </td><td>  </td><td> Relative entropy between two 
		probability distributions</td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#entanglement"> entanglement </a> </td><td>  </td><td>Entanglement entropy of a pure 
		    quantum state</td></tr>

		<tr><td><a href="#neg"> neg </a> </td><td>  </td><td> Negativity of a quantum state</td></tr>
		
		<tr><td><a href="#log_neg"> log_neg </a> </td><td>  </td><td>Logarithmic negativity of a quantum state</td></tr>

		<tr><td><a href="#concurrence"> concurrence </a> </td><td>  </td><td>Concurrence of a two-qubit 
		    quantum state</td></tr>

		<tr><td><a href="#EoF"> EoF </a> </td><td>  </td><td>Entanglement of formation of a two-qubit 
		    quantum state</td></tr>

		<tr><td><a href="#ent_check_CMC"> ent_check_CMC </a> </td><td>  </td><td> To check if a bipartite state 
		    is entangled or not (based on covariant matrix criteria, can be used to detect bound entangled states)</td></tr>
		
		<tr><td><a href="#schmidt"> schmidt, schmidt_full </a> </td><td>  </td><td> Schmidt decomposition of a 
		    bipartite pure state</td></tr>

		<tr><td><a href="#schmidt_base"> schmidtA, schmidtB, schmidtAB,
		      schmidtA_full, schmidtB_full, schmidtAB_full </a> </td><td>  </td><td> Schmidt vectors of a bipartite pure state</td></tr>
		

		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#l1_coh"> l1_coh </a> </td><td>  </td><td>l1-norm coherence of a quantum state</td></tr>

		<tr><td><a href="#rel_entropy_coh"> rel_entropy_coh </a> </td><td>  </td><td>Relative entropy of coherence of a 
		quantum state</td></tr>
		

		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#HS_dist"> HS_dist </a> </td><td>  </td><td>Hilbert-Schmidt distance between
		    two density matrices</td></tr>	      

		<tr><td><a href="#tr_dist"> tr_dist </a> </td><td>  </td><td>Trace distance between two density matrices</td></tr>
		
		<tr><td><a href="#bures_dist"> Bures_dist </a> </td><td>  </td><td>Bures distance between two density matrices</td></tr>

		<tr><td><a href="#fidelity"> fidelity </a> </td><td>  </td><td>Fidelity between two density matrices</td></tr>
		

		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#apply"> apply </a> </td><td>  </td><td>To apply a quantum gate to a quantum state</td></tr>	      
		
		<tr><td><a href="#apply_ctrl"> apply_ctrl </a> </td><td>  </td><td>To apply a quantum gate or a set of Kraus operators to 
		    a quantum state as a controlled gate</td></tr>
		    
		<tr><td><a href="#apply_ctrl"> make_ctrl </a> </td><td>  </td><td>To convert a quantum gate into 
		    a controlled quantum gate</td></tr>

		<tr><td><a href="#measure"> measure </a> </td><td>  </td><td>To measure a quantum state using a set of Kraus 
		    or projection operators</td></tr>

		<tr><td><a href="#measure_comp"> measure_comp </a> </td><td>  </td><td>To measure a quantum state in the 
		    computational basis</td></tr>



	      </tbody>
	    </table>
	  
	  <a href="#top">Go to top</a>
	  <br><br>



	  <a name="discord_func"></a>
	  <b>Classes for discord like features</b><br>
	  <ul>
	    <li> <b>Note:</b> These features depend on <a href = "http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a>. </li> 
	    <li> <b>Note:</b> If you want to use old API's for discord like function, define <code>QICLIB_USE_OLD_DISCORD</code> macro 
	    before including <code>QIClib</code> header. See  <a href="#macro">preprocessor macros in QIClib</a> for details. Old API's for 
	    discord like functions are not maintained anymore.</li> <br>
		</ul>
	    <table>
	      <tbody>

		<tr><td><a href="#discord_space"> discord_space </a> </td><td>  </td><td> Computational space for calculating quantum discord
		(actual as well as constrained-regular) for quantum states when measurement is done over a qubit or qutrit system</td></tr>
		    
		<tr><td><a href="#deficit_space"> deficit_space </a> </td><td>  </td><td> Computational space for calculating quantum work
		deficit (actual as well as constrained-regular) for quantum states when measurement is done over a qubit or 
		qutrit system</td></tr>
		
	      </tbody>
	    </table>
	  </ul>
	  <a href="#top">Go to top</a>
	  <br><br>





	  <hr><hr>

	  <font color="blueviolet">In this documentation the <i>mat</i>, <i>cx_mat</i>, <i>vec</i>, and <i>cx_vec</i>  
	  type is used for convenience. 
	  But every function should also work with <i>float</i> counterparts, like <i>fmat</i>, <i>cx_fmat</i>, <i>fvec</i>, 
	  and <i>cx_fvec</i>.</font>

	  <hr><hr>

	  <h3>Classes and constants</h3>
	  <hr> <br>


<!--	  <a name="eps"></a>
	  <b>_precision::eps</b><br><br>
	  <ul>
	    <li>Precision for floating point arithmetic. </li><br> 
	    <li>For floating point arithmetics, every <code>float</code> or <code>double</code> <i>less than</i> 
	      <code>_precision::eps&lt;float&gt;::value</code> or <code>_precision::eps&lt;double&gt;::value</code> will be treated as zero.</li><br>
	    
	    <li> Default value for <code>_precision::eps&lt;float&gt;::value</code> is <code>10*std::numeric_limits&lt;float&gt;::epsilon()</code>, 
	      and <code>_precision::eps&lt;double&gt;::value</code> is <code>100*std::numeric_limits&lt;float&gt;::epsilon()</code>. 
	      It can be changed by editing <code>include/QIClib_bits/class/constants.hpp</code> file.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>
-->

	  <a name="init"></a>
	  <b>Init</b><br>
	  <ul>
	    <li>Class for library initialization. Automatically loaded if you use this library. </li>

	    <li>Prints current time and date upon program start. After program completion, prints current time and date
	    along with total runtime.</li>

	    <li>To disable this feature, define <code>QICLIB_NO_INIT_MESSAGE</code> macro before including <code>QIClib</code> header.
	    See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="spm"></a>
	  <b>SPM&lt;POD_TYPE&gt;<br> spm <br> spmf</b><br>
	  <ul>
	    <li> Several predefined special matrices and vectors like, basis, projectors, operators etc. 
	      <code>POD_TYPE</code> can be either <code>double</code> or <code>float</code>.</li>

	    <li> This is a singleton class, can be constructed only once. 
				You can only take <code>const</code> reference of this class using <code>SPM&lt;POD_TYPE&gt;::get_instance()</code>
				function (see below). For the ease of use, QIClib library automatically instantiates this class for <code>double</code> and
				<code>float</code> as <code>spm</code> and <code>spmf</code> respectively. Use of <code>spm</code> or <code>spmf</code>
				is recommended rather than explicit <code>SPM&lt;POD_TYPE&gt;::get_instance()</code>.</li>
	     <!--
	      Instantiated by <code>static const SPM&lt;double&gt;& spm  = SPM&lt;double&gt;::get_instance();</code> for 
	      <code>double</code> or <code>static const SPM&lt;float&gt;& spmf  = SPM&lt;float&gt;::get_instance();</code> for
	      <code>float</code>. You don't need to do this as it is automatically instantiated if you use this library. Just use <code>spm</code> or <code>spmf</code> (see below). </li><br>
-->
	    <li> <code>spm.S</code> gives <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> 
	      of Pauli matrices as constant complex matrices (<code>const cx_mat</code>). <code>spm.S(0)</code>, 
	      <code>spm.S(1)</code>, <code>spm.S(2)</code>, and <code>spm.S(3)</code> are respectively <i>I<sub>2x2</sub></i>, 
	      <i> &sigma;<sub>x</sub></i>, <i> &sigma;<sub>y</sub></i>, and <i> &sigma;<sub>z</sub></i>.
	      <br>(Similarly for <code>spmf.S</code>).</li>

	    <li> <code>spm.basis2</code> gives <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of 
	      2-dimensional basis vectors as constant complex column vectors (<code>const cx_vec</code>). <code>spm.basis2(0, i)</code> 
	      and <code>spm.basis2(1, i)</code> 
	      are respectively |0&gt and |1&gt in <i>i</i> direction <i>(i = 0, 1, 2, 3)</i>. <br>
	      <code>spm.proj2</code> gives corresponding projectors as constant complex matrices (<code>const cx_mat</code>). 
	      <br>(Similarly for <code>spmf.basis2</code> and <code>spmf.proj2</code>).</li>

	    <li> <code>spm.basis3</code> gives <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of 
	      3-dimensional basis vectors constant complex column vectors (<code>const cx_vec</code>). <code>spm.basis3(0, i)</code>, 
	      <code>spm.basis3(1, i)</code> and 
	      <code>spm.basis3(2, i)</code> are respectively |0&gt, |1&gt and |2&gt in <i>i</i> direction <i>(i = 0, 1, 2, 3)</i>. 
	      <br><code>spm.proj3</code> gives corresponding projectors constant complex matrices (<code>const cx_mat</code>). 
	      <br>(Similarly for <code>spmf.basis3</code> and <code>spmf.proj3</code>).</li>

		 <li> <code>spm.bell.phim</code>, <code>spm.bell.phip</code>, <code>spm.bell.psim</code>, and <code>spm.bell.psip</code>
				give four Bell states as constant real vectors (<code>const vec</code>).				
				<br>(Similarly for <code>spmf.bell</code>).</li>	
				
	    <li> <b>Note:</b> You cannot take a copy of the whole <code>SPM&lt;POD_TYPE&gt;</code> class, but you can take reference to
	    	<code>const</code>. For this use <code>const SPM&lt;POD_TYPE&gt;& SOMENAME  = SPM&lt;POD_TYPE&gt;::get_instance();</code>.
	    	However, for each member variables, like <code>S</code> or <code>proj3</code> etc., you can either take a copy or reference 
	      to <code>const</code> (See the following example).
	      
	      <br><font color="blueviolet"><i><b>Note</b>: Taking copy or reference to <code>const</code> is not advisable for the 
	      member variables. Direct use of member variables is recommended.</i></font></li>


	    <li> Example:
	      <pre> 
	  	const SPM&lt;double&gt;& myspm 
   	 	   = SPM&lt;double&gt;::get_instance(); // take const ref of the whole class
	   
		const cx_mat& S1 = spm.S(1);   // \sigma_x matrix, take reference
		cx_mat S2 = spm.S(2);          // \sigma_y matrix, take a copy

		const cx_vec& plus = spm.basis2(0, 1);     // |+&gt state
		const cx_mat& proj_plus = spm.proj2(0, 1); // |+&gt&lt+| projector

		const cx_vec& U = spm.basis3(0, 3); // 1st eigenvector of 
                //Spin S_z operator in 3-dim

		const cx_mat& M = spm.basis3(1, 3); // 2nd eigenvector of 
                //Spin S_z operator in 3-dim
	
		const cx_mat& M = spm.basis3(2, 3); // 3rd eigenvector of 
                //Spin S_z operator in 3-dim
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="gates"></a>
	  <b>GATES&lt;POD_TYPE&gt;<br> gates <br> gatesf</b><br>
	  <ul>
	    <li> Several predefined constant quantum gates and generators of quantum gates. 
	      <code>POD_TYPE</code> can be either <code>double</code> or <code>float</code>.</li>

	    <li> This is a singleton class, can be constructed only once. 
				You can only take <code>const</code> reference of this class using <code>GATES&lt;POD_TYPE&gt;::get_instance()</code>
				function (see below). For the ease of use, QIClib library automatically instantiates this class for <code>double</code> and
				<code>float</code> as <code>gates</code> and <code>gatesf</code> respectively. Use of <code>gates</code> or 
				<code>gatesf</code> is recommended rather than explicit <code>GATES&lt;POD_TYPE&gt;::get_instance()</code>.</li>
	     
	    <li> <code>gates.X</code>, <code>gates.Y</code>, <code>gates.Z</code>, and <code>gates.Had</code> give Pauli X,Y, and Z and 
	    Hadamard gates respectively. <code>gates.Y</code> is a constant complex matrix (<code>const cx_mat</code>), 
	    where as others are constant real matrices (<code>const mat</code>). 
	    <br>(Similarly for <code>gatesf.X</code>, <code>gatesf.Y</code>, <code>gatesf.Z</code>, and <code>gatesf.Had</code>).</li>
	    
		 <li> <code>gates.CNOT</code>, <code>gates.CZ</code> and <code>gates.swap</code> give controlled NOT, controlled Pauli Z,
		 and swap gates respectively as constant real matrices (<code>const mat</code>).
	    <br>(Similarly for <code>gatesf.CNOT</code>, <code>gatesf.CZ</code>, and <code>gatesf.swap</code>).</li>    
	    
		 <li> <code>gates.Tof</code> and <code>gates.Fred</code> give Toffoli and Fredkin gates respectively as constant 
		 real matrices (<code>const mat</code>).
	    <br>(Similarly for <code>gatesf.Tof</code> and <code>gatesf.Fred</code>).</li>	    
	    	    
	    
	    <li> <code>gates.U2(theta, unitV)</code>: Generates a member of U(2) group. <code>theta</code> is a <code>double</code>
			and <code>uniV</code> is a 3-dimensional unit column vector (<code>vec</code>). Output is a fixed size 2x2 complex 
			unitary matrix (<code>cx_mat22</code>) as <i>U = cos(theta/2) I + i sin(theta/2)(unitV.&sigma;)</i>. 
			<br>(Similarly for <code>gatesf.U2(theta, unitV)</code>).</li>

		
		<li> <code>gates.PS(phi)</code>: Generates a phase-shift gate according to the angle <code>phi</code> (<code>double</code>).
			Output is a fixed size 2x2 complex unitary matrix (<code>cx_mat22</code>) as <i>U = diag(1, exp(i*phi))</i>. 
			<br>(Similarly for <code>gatesf.PS(phi)</code>).</li>


		
		 <li> <code>gates.qft(dim)</code>: Generates unitary matrix for quantum Fourier transform of dimension 
		 specified by <code>dim</code>, as complex matrix (<code>cx_mat</code>). 
		 <br>(Similarly for <code>gatesf.qft(dim)</code>).</li>
		 
		 
<!--		 <li> <code>gates.make_ctrl(U, ctrl, subsys, dim)</code>: Convert a quantum gate <code>U</code> (<code>mat</code> 
		 or <code>cx_mat</code>) into a controlled quantum gate, where <code>subsys</code> is a <code>uvec</code> containing the indices
		  of subsystems where <code>U</code> will be applied (target subsystems), and <code>ctrl</code> is a <code>uvec</code> 
		  containing the indices of control subsystems. <code>dim</code> is a <code>uvec</code> containing the dimensions of all subsystems.
		  <br><b>Note:</b> Indices in <code>subsys</code> and <code>ctrl</code> start from 1, i.e., 
		  first party has the index 1, second party has the index 2 and so on.
		  <br><b>Note:</b> Return type is same as that of <code>U</code>.
		  <br>(Similarly for <code>gatesf.make_ctrl(U, ctrl, subsys, dim)</code>.) </li><br>
		 
		 <li> <code>gates.make_ctrl(U, ctrl, subsys, n, dim = 2)</code>: Same as above.
			Here <code>n</code> specifies the total number of subsystems, and every subsystem has same dimension specified by <code>dim</code>
			(optional, by default it is 2). <code>n</code> and <code>dim</code> both are 
			<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>.
			<br>(Similarly for <code>gatesf.make_ctrl(U, ctrl, subsys, n, dim = 2)</code>.) </li><br>
-->		 
		 		
	    <li> <b>Note:</b> You cannot take a copy of the whole <code>GATES&lt;POD_TYPE&gt;</code> class, but you can take reference to
	    	<code>const</code>. For this use <code>const GATES&lt;POD_TYPE&gt;& SOMENAME  = GATES&lt;POD_TYPE&gt;::get_instance();</code>.
	    	However, for each member variables, like <code>Had</code> or <code>CNOT</code> etc., you can either take a copy or reference 
	      to <code>const</code>. Member functions like <code>U2</code> or <code>qft</code> etc. behave like 
	      normal functions. (See the following example).
	      
	      <br><font color="blueviolet"><i><b>Note</b>: Taking copy or reference to <code>const</code> is not advisable for the 
	      member variables. Direct use of member variables is recommended.</i></font></li>


	    <li> Example:
	      <pre> 
	  	const GATES&lt;double&gt;& mygates 
   	 	   = GATES&lt;double&gt;::get_instance(); // take const ref of the whole class
	   
		const mat& XX = gates.X;   // \sigma_x matrix, take reference
		cx_mat YY = gates.Y;       // \sigma_y matrix, take a copy

		cx_mat Q = gates.qft(8); // quantum Fourier transform 
		                         // for 8 dimension 
	<!--	mat CXX 
		    = make_ctrl(gates.X,{1},{2},{2,2}); // make control Pauli X gate 
		                                        // where control qubit is 1
		                                        // and target qubit is 2
													 
		mat CXX2 = make_ctrl(gates.X,{1},{2},2,2); // same as above
		mat CXX3 = make_ctrl(gates.X,{1},{2},2);   // same as above
		                                           // default dim = 2 is taken
	-->  </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>





	  <a name=func></a>
	  <b>Func&lttype&gt<br> func <br> funcf</b><br>
	  <ul>
	    <li> Class with several predefined static member functions to be used with <code><a href = "#funcm_sym">funcm_sym</a></code> or 
	      <code><a href = "#funcm_gen">funcm_gen</a></code>.</li>
	    
	    <li> <code>func</code> is an alias for <code>Func&lt;double&gt;</code> and <code>funcf</code> is an alias for 
	      <code>Func&lt;float&gt;</code>.</li>
	    
	    <li> Every member function takes one <i>complex</i> type and returns one <i>complex</i> type.</li>
	    
	    <li> List of member functions:
	      <ul>
		<li> func::sin<br>
 			  func::cos<br>
			  func::tan</li>
			 
		<li> func::asin<br>
		     func::acos<br>
		     func::atan</li>
		
		<li> func::sinh<br>
		     func::cosh<br>
		     func::tanh</li>

		<li> func::asinh<br>
		     func::acosh<br>
		     func::atanh</li>

		<li> func::sqrt<br>
		     func::log<br>
		     func::log2</li>
		
		<li> func::real<br>
		     func::imag<br>
		     func::norm</li>
	      </ul>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name="RandomDevices"></a>
	  <b>RandomDevices<br>rdevs</b><br>
	  <ul>
	    <li> Predefined random number engines/generators, used in functions like <a href="#randU">randU</a> etc. 
	    This class is thread safe.</li>

		<li>  This is a singleton class, can be constructed only once. 
				You can only take reference of this class using <code>RandomDevices::get_thread_local_instance()</code>
				or <code>RandomDevices::get_instance()</code>, <font color="blueviolet"><i>but this is not advisable at all</i></font>.
				QIClib library automatically instantiates this class as <code>redvs</code>.
				Use <code>rdevs</code> rather than explicit  <code>RandomDevices::get_thread_local_instance()</code> or
				<code>RandomDevices::get_instance()</code>.</li>

	    <li>There are two member variables, <code>rd</code> and <code>rng</code>. <code>rd</code> is an instance of 
	    <code>std::random_device</code>, and <code>rng</code> is an instance of Mersenne twister engine, <code>std::mt19937_64</code> 
	    or <code>std::mt19937</code> depending on whether <a href="http://arma.sourceforge.net/">Armadillo</a> uses 64bit integers or 
	    not. See <a href="http://arma.sourceforge.net/docs.html#uword">this</a>. </li>

	    <li> By default, <code>rng</code> is seeded with the random return value of <code>rd</code>. To seed <code>rng</code> 
	    with user defined value, use <code>rdevs.set_seed(YOUR_SEED)</code>. To seed <code>rng</code> with the random return 
	    value of <code>rd</code> again, use <code>rdevs.set_seed_random()</code>.</li>

	    <li> Example:
	      <pre>
		std::cauchy_distribution&lt;double&gt; dis(0,1);
		// Cauchy distribution with parameters 0 and 1

		double a[10], b[10], c[10];

		// seed is random, by default
		for(int i = 0; i < 10; ++i) {
		  a[i] = dis(rdevs.rng); // generate 10 random number
		                         // according to Cauchy distribution 
		                         // with parameters 0 and 1	   
		}
				   
		rdevs.set_seed(10); // set seed to 10
		
		for(int i = 0; i < 10; ++i) {
		  b[i] = dis(redvs.rng); // generate 10 random number
		                         // according to Cauchy distribution 
		                         // with parameters 0 and 1	   
		}
						      
		rdevs.set_seed_random(); // again seed is random
		
		for(int i = 0; i < 10; ++i) {
		  c[i] = dis(rdevs.rng); // generate 10 random number
		                         // according to Cauchy distribution 
		                         // with parameters 0 and 1	   
		}
			</pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><hr>
	  
	  <h3>Functions</h3>
	  <hr> <br>


	  
	  <a name="is_Hermitian"></a>
	  <b>is_Hermitian(A)<br>is_Hermitian(A, atol, rtol)</b><br>
	  <ul>
	    <li> Hermiticity check. Returns <code>true</code> if <code>A</code> is real symmetric (<code>mat</code>) or 
	    Hermitian (<code>cx_mat</code>), 
	    else <code>false</code>.</li>

	    <li> <code>atol</code> and <code>rtol</code> are optional.
				By default, <code>atol</code> is floating point precision used in QIClib, and <code>rtol</code> is 10 times of that.
				See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>			
				    
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>
	  



	  <a name="is_Unitary"></a>
	  <b>is_Unitary(A)<br>is_Unitary(A, atol, rtol)</b><br>
	  <ul>
	    <li> Unitarity check. Returns <code>true</code> if <code>A</code> is real orthogonal (<code>mat</code>) or unitary 
	    (<code>cx_mat</code>), else <code>false</code>.</li>
	    
	    <li> <code>atol</code> and <code>rtol</code> are optional.
				By default, <code>atol</code> is floating point precision used in QIClib, and <code>rtol</code> is 10 times of that.
				See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>			
		
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>
	  
	  
	  
   <a name="is_Normal"></a>
	  <b>is_Normal(A)<br>is_Normal(A, atol, rtol)</b><br>
	  <ul>
	    <li> To check whether the the matrix is normal or not. 
	    Returns <code>true</code> if <code>A</code> is a normal matrix, else <code>false</code>.</li>
	    
	    <li> <code>atol</code> and <code>rtol</code> are optional.
				By default, <code>atol</code> is floating point precision used in QIClib, and <code>rtol</code> is 10 times of that.
				See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>			
		
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="is_pure"></a>
	  <b>is_pure(A)<br>is_pure(A, check_norm = true)<br>is_pure(A, check_norm, tol)</b><br>
	  <ul>
	    <li> To check purity of a row/column vector or density matrix. 
	    Returns <code>true</code> if <code>A</code> is a pure state, else <code>false</code>.</li>
	    
	    <li> <code>check_norm</code> and <code>tol</code> are optional. By default, <code>check_norm = true</code> and 
	    normalization of the vector or matrix will be checked, and <code>tol</code> is floating point precision used in QIClib.
	    See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>	    
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>
	  


	  <a name="is_valid_state"></a>
	  <b>is_valid_state(A)<br>is_valid_state(A, tol)</b><br>
	  <ul>
	    <li> To check whether the matrix or vector represents a valid quantum state. Returns <code>true</code> if <code>A</code> is a 
	      valid quantum state, else <code>false</code>.</li>
	    
	    <li> <code>tol</code> is optional, by default, <code>tol</code> is floating point precision used in QIClib.
	    See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>

	    <li> <b>Note:</b> Normalization will always be checked.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  
	  
	  <hr><br>



	  <a name="is_diagonalizable"></a>
	  <b>is_diagonalizable(A)</b>
	  <ul>
	    <li> To check whether the matrix is diagonalizable. 
	    Returns <code>true</code> if <code>A</code> is diagonalizable, else <code>false</code>.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  
	  
	  <hr><br>



	  <a name="is_equal"></a>
	  <b>is_equal(A, B)<br>is_equal(A, B, typecheck = false)<br>is_equal(A, B, typecheck, atol, rtol)</b><br>
	  <ul>
	    <li> To check whether two matrices are equal in values. 
	    Returns <code>true</code> if <code>A</code> and <code>B</code> are element-wise (approximately) equal, 
	    else <code>false</code>.</li>
	    
	    <li> <code>typecheck</code> is optional. By default, <code>typecheck=false</code>, and element types 
	    (<i>complex</i> or <i>real</i>) of <code>A</code> and <code>B</code> need not to be same.</li>

	    <li>	<code>atol</code> and <code>rtol</code> are optional.
				By default, <code>atol</code> is floating point precision used in QIClib, and <code>rtol</code> is 10 times of that.
				See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>
	  
	  
	  
	  
	  <a name="dense_to_sparse"></a>
	  <b>dense_to_sparse(A)<br>dense_to_sparse(A, tol)</b><br>
	  <ul>
	    <li> To Convert a dense matrix <code>A</code> 
		    (<a href="http://arma.sourceforge.net/docs.html#Mat">Mat</a>) to a sparse 
		    (<a href="http://arma.sourceforge.net/docs.html#SpMat">SpMat</a>) matrix with the same element type.</li>

	    <li>	<code>tol</code> is optional. Any element having absolute value less than <code>tol</code> will be treated as zero.
				By default, <code>tol</code> is floating point precision used in QIClib.
				See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>
	  


	  <a name="sparse_to_dense"></a>
	  <b>sparse_to_dense(A)</b><br>
	  <ul>
	    <li> To Convert a sparse matrix <code>A</code> 
		    (<a href="http://arma.sourceforge.net/docs.html#SpMat">SpMat</a>) to a dense 
		    (<a href="http://arma.sourceforge.net/docs.html#Mat">Mat</a>) matrix with the same element type.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  


	  <a name="range"></a>
	  <b>range(stop)<br>range(start, stop)<br>range(start, stop, step)</b>
	  <ul>
	    <li> Similar to Python's <code>range()</code> function. Useful in range-based <code>for</code> loops. 
	      Returns <code>std::vector</code> of arithmetic (floating point or integral types) values, from (and including) 
	      <code>start</code> to (and excluding) <code>stop</code> with step-size equal to <code>step</code>.</li>
	    
	    <li> <code>start</code> and <code>step</code> are optional, by default, <code>start = 0</code> and <code>step = 1</code>.</li>

	    <li> Example:
	      <pre>
		for(auto&& i : range(10))
		{
		// i from 0 to 9
		//do something
		}
		
		std::vector&lt;int&gt; R1 = range(2, 10, 2); 
		std::vector&lt;double&gt; R2 = range(10, -1.5, -0.5);
	      </pre>
	    </li>

	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>




	  <a name="TrX"></a>
	  <b>TrX(A, subsys) <br> TrX(A, subsys, dim) </b><br>
	  <ul>
	    <li> Partial trace of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices
	     of to be traced out subsystems.</li>
	    
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>
	    
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>
	    
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the
	     index <i>2</i> and so on.</li>
	    
	    <li> Example:
	      <pre>
		mat A = randn&lt;mat&gt;(8, 8); // 8x8 matrix
		A *= A.t(); // make Hermitian
		A /= trace(A); //normalize

		cx_mat B = randRho(12); // random 12x12 density matrix, see randRho()
		
		// trace out 2nd and 3rd party
		mat A1 = TrX(A, {2, 3}); // all dim are 2, total 3 parties
		mat A2 = TrX(A, {2, 3}, 2); // same as before
		
		// trace out 2nd and 3rd party
		cx_mat B1 = TrX(B, {2, 3}, {2, 3, 2}); // explicitly written dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="Tx"></a>
	  <b>Tx(A, subsys) <br> Tx(A, subsys, dim) </b><br>
	  <ul>
	    <li> Partial transpose of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of to 
	      be transposed subsystems.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>
	    
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>
	    
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	    second party has the index <i>2</i> 
      and so on.</li>
	    
	    <li> Example:
	      <pre>
		mat A = randn&lt;mat&gt;(8, 8); // 8x8 matrix
		A *= A.t(); // make Hermitian
		A /= trace(A); //normalize

		cx_mat B = randRho(12); // random 12x12 density matrix, see randRho()
		
		// transpose 2nd and 3rd party
		mat A1 = Tx(A, {2, 3}); // all dim are 2, total 3 parties
		mat A2 = Tx(A, {2, 3}, 2); // same as before

		// transpose 2nd and 3rd party
		cx_mat B1 = Tx(B, {2, 3}, {2, 3, 2}); // explicitly written dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="sysperm"></a>
	  <b>sysperm(A, perm) <br> sysperm(A, perm, dim) </b><br>
	  <ul>
	    <li> Permute subsystems of a quantum state, where <code>perm</code> is a <code>uvec</code> 
	    containing the permutation of subsystem indices.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>
	    
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing dimensions 
	    of every subsystem. 
	     When it is unsigned integer type, all subsystems are supposed to have same dimensions (equal to <code>dim</code>). 
	     By default, it is <i>2</i>. 
	     If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	     containing dimensions of every subsystem.</li>
	    
	    <li> Indices in <code>perm</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and 
	      so on.</li>
	    
	    <li> Example:

	      <pre>
		mat A = randn&lt;mat&gt;(8, 8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randRho(12); // random 12x12 density matrix, see randRho()
		
		// permute 2nd and 3rd party
		mat A1 = sysperm(A, {1, 3, 2}); // all dim are 2, total 3 parties
		mat A2 = sysperm(A, {1, 3, 2}, 2); // same as before
		
		// permute 2nd and 3rd party
		cx_mat B1 = sysperm(B, {1, 3, 2}, {2, 3, 2}); // explicitly written dimensions
		                                              // for B1, dim = {2, 2, 3} 
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="sqrtm_sym"></a>
	  <b>sqrtm_sym(A)</b><br>
	  <ul>
	    <li>Principal square root of real symmetric or Hermitian matrices.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li>
	    
	    <li> Due to generality, always returns <i>complex</i> matrices (<code>cx_mat</code>), even for <i>positive real</i> 
	    matrices.</li>

	    <li> <b>Note:</b> <code>sqrtm_sym</code> is faster than <code><a href = "#sqrtm_gen">sqrtm_gen</a></code>. For real symmetric or 
	      Hermitian matrices always use
	      <code>sqrtm_sym</code>.</li>
	      
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		A *= A.t(); // make hermitian
		
		mat B = randn&lt;mat&gt;(5,5);
		B *= B.t(); // make hermitian
		
		cx_mat sqrtA = sqrtm_sym(A);

		cx_mat sqrtB = sqrtm_sym(B);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="sqrtm_gen"></a>
	  <b>sqrtm_gen(A)</b>
	  <ul>
	    <li>Principal square root of general square matrices.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li>
	    
	    <li> Due to generality, always returns <i>complex</i> matrices, even for <i>positive real</i> matrices.</li>
	    
	    <li> <b>Note:</b> <code><a href = "#sqrtm_sym">sqrtm_sym</a></code> is faster than <code>sqrtm_gen</code>. For real symmetric or 
	      Hermitian matrices always use
	      <code><a href = "#sqrtm_sym">sqrtm_sym</a></code>.</li>

	    <li> <b>Note:</b> Only works if <code>A</code> is diagonalizable matrix. To make sure, use <code><a href="#is_diagonalizable">is_diagonalizable</a></code>
	      function first.</li>
	      
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		
		mat B = randn&lt;mat&gt;(5,5);
		
		cx_mat sqrtA = sqrtm_gen(A);

		cx_mat sqrtB = sqrtm_gen(B);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="powm_sym"></a>
	  <b>powm_sym(A, n)</b><br>
	  <ul>
	    <li>Matrix power for real symmetric or Hermitian matrices.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <code>n</code> can be any type of scaler, 
	      like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li>
	      
	    <li> Due to generality, always returns <i>complex</i> matrices (if <code>n</code> is not of <i>integer type</i>), 
	     even for <i>positive real</i> matrices. If <code>n</code> is of <i>integer type</i> matrix element 
	     type will be preserved.</li>

	    <li> <b>Note:</b> <code>powm_sym</code> is faster than <code><a href = "#powm_gen">powm_gen</a></code>. For real symmetric or 
	      Hermitian matrices always use
	      <code>powm_sym</code>.</li>
	    
	    <li> Example:

	      <pre>
		mat A = randn&lt;mat&gt;(5, 5);
		A *= A.t(); // make hermitian
		
		mat A_3 = powm_sym(A, 3);

		cx_mat A_3.14 = powm_sym(A, 3.14);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="powm_gen"></a>
	  <b>powm_gen(A, n)</b><br>
	  <ul>
	    <li>Matrix power for general square matrices.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <code>n</code> can be any type of scaler, 
	      like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li>
	      
	    <li> Due to generality, always returns <i>complex</i> matrices (if <code>n</code> is not of <i>integer type</i>), 
	    even for <i>positive real</i> matrices.
	     If <code>n</code> is of <i>integer type</i> matrix element type will be preserved.</li>
	      
	    <li> <b>Note:</b> <code><a href = "#powm_sym">powm_sym</a></code> is faster than <code>powm_gen</code>. 
	      For real symmetric or Hermitian matrices always use
	      <code><a href = "#powm_sym">powm_sym</a></code>.</li>
	    
	    <li> <b>Note:</b> Only works if <code>A</code> is diagonalizable matrix. To make sure, 
	    use <code><a href="#is_diagonalizable">is_diagonalizable</a></code>
	    function first.</li>
	    
	    <li> Example:

	      <pre>
		mat A = randn&lt;mat&gt;(5, 5);
		
		mat A_3 = powm_gen(A, 3);

		cx_mat A_3.14 = powm_gen(A, 3.14);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="expm_sym"></a>
	  <b>expm_sym(A)<br>expm_sym(A, n)</b><br>
	  <ul>
	    <li>Matrix exponential for real symmetric or Hermitian matrices.<code>expm_sym(A,n)</code> calculates <i>exp(n*A)</i>.</li>
	    
	    <li> <code>A</code> has to be a square real symmetric or Hermitian matrix (<code>mat</code> or <code>cx_mat</code>). 
	      <code>n</code> can be any type of scaler, like <code>double</code>, <code>complex&lt;double&gt;</code>, 
	      <code>int</code> etc.</li>
	    
	    <li> <b>Note:</b> <code>expm_sym</code> is often slower but more accurate than <code><a href = "#expm_gen">expm_gen</a></code> 
	      or <a href="http://arma.sourceforge.net">Armadillo's</a> 
	      <code><a href = "http://arma.sourceforge.net/docs.html#expmat">expmat</a></code>. 
	      But for very large matrices it can be faster than the alternatives.</li>
	    
	    <li> Example:
	      <pre>
		mat A = randn&lt;mat&gt;(5,  5);
		A *= A.t(); // make hermitian
		
		mat A_e = expm_sym(A);

		complex&lt;double&gt; I (0.0, 1.0);
		cx_mat AI_e = expm_sym(A, I); // exp(I*A)
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="expm_gen"></a>
	  <b>expm_gen(A)</b><br>
	  <ul>
	    <li>Matrix exponential for general square matrices.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li>
	    
	    <li> <b>Note:</b> <code>expm_gen</code> is basically same as <a href="http://arma.sourceforge.net">Armadillo's</a> 
	      <code><a href = "http://arma.sourceforge.net/docs.html#expmat">expmat</a></code>, and only to be used with older 
	      versions of <a href="http://arma.sourceforge.net">Armadillo</a>.</li>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5);
		
		cx_mat A_e = expm_gen(A);

		complex&lt;double&gt; I (0.0, 1.0);
		cx_mat AI_e = expm_gen(I*A);
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
		<hr><br>



	  <a name="funcm_sym"></a>
	  <b>funcm_sym(A, function pointer)<br>funcm_sym(A, functor)<br>funcm_sym(A, lambda function)</b><br>
	  <ul>
	    
	    <li><a href = "https://en.wikipedia.org/wiki/Matrix_function">Matrix function</a> 
	    for real symmetric or Hermitian matrices.</li>
	    
	    <li> <code>A</code> has to be a square real symmetric or Hermitian matrix (<code>mat</code> or <code>cx_mat</code>). 
	      <i>function pointer</i>, <i>functor</i> or <i>lambda function</i> has to take one <i>complex</i> type and 
	      return one <i>complex</i> type.</li>
	    
		<li> Due to generality, always returns <i>complex</i> matrices.</li>	    
	    
	    <li> If you want to use standard <i>complex</i> functions, use static member functions of 
	    <code><a href="#func">Func&lt;type&gt;</a></code> class.</li>
	    
	    <li> <b>Note:</b> <code>funcm_sym</code> is faster than <code><a href = "#funcm_gen">funcm_gen</a></code>. For real symmetric or 
	      Hermitian matrices always use <code>funcm_sym</code>. </li>
	    
	    <li> <b>Note:</b> If you want to transform the matrix element-wise, use 
	      <code><a href="http://arma.sourceforge.net/docs.html#transform">.transform</a></code> instead.</li>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5);
		A *= A.t(); // make hermitian
		
		//define a lambda function
		auto sinm = [](complex&lt;double&gt; a){return std::sin(a);};

		cx_mat A_sin = funcm_sym(A, sinm); // calculate sin(A)

		cx_mat A_sin2 = funcm_sym(A, func::sin); // same as A_sin, 
		                                         //using <code>Func&lt;type&gt;</code> class
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="funcm_gen"></a>
	  <b>funcm_gen(A, function pointer)<br>funcm_gen(A, functor)<br>funcm_gen(A, lambda function)</b><br>
	  <ul>
	    
	    <li><a href = "https://en.wikipedia.org/wiki/Matrix_function">Matrix function</a> for general square matrices.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <i>function pointer</i>, 
	      <i>functor</i> or <i>lambda function</i> has to take one <i>complex</i> type and return one <i>complex</i> type.</li>
	    
	     <li> Due to generality, always returns <i>complex</i> matrices.</li>
	     
	    <li> If you want to use standard <i>complex</i> functions, use static member functions of 
	    <code><a href="#func">Func&lt;type&gt;</a></code> class.</li>
	    
	    <li> <b>Note:</b> <code><a href = "#funcm_sym">funcm_sym</a></code> is faster than <code>funcm_gen</code>. 
	    For real symmetric or Hermitian matrices always use <code><a href = "#funcm_sym">funcm_sym</a></code>.</li>

	    <li> <b>Note:</b> Only works if <code>A</code> is diagonalizable matrix. To make sure, use 
	    	<code><a href="#is_diagonalizable">is_diagonalizable</a></code> function first.</li>	    

	    <li> <b>Note:</b> If you want to transform the matrix element-wise, use 
	      <code><a href="http://arma.sourceforge.net/docs.html#transform">.transform</a></code> instead.</li>
	    

	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5);
		
		//define a lambda function
		auto sinm = [](complex&lt;double&gt; a){return std::sin(a);}; 

		cx_mat A_sin = funcm_gen(A, sinm); // calculate sin(A)

		cx_mat A_sin2 = funcm_gen(A, func::sin); // same as A_sin, 
		                                         // using <code>Func&lt;type&gt;</code> class
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="tensor"></a>
	  <b>tensor(A, B, ...)</b><br>
	  <ul>
	    <li>Tensor product of arbitrary no. of matrices <code>A,B,...</code>. Return type is deduced from the types of input matrices.</li>
	    <li> Can also take <code>std::vector</code> and 
	    <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of matrices.</li>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5); //complex matrix
		cx_mat B = randn&lt;cx_mat&gt;(4, 4); //complex matrix
		cx_mat C = randn&lt;cx_mat&gt;(3, 3); //complex matrix
		mat D = randn&lt;mat&gt;(6, 6);       //real matrix
		
		cx_mat T1 = tensor(A, B, C, D); // tensor product of A,B,C,D 
		                                // return type is deduced as cx_mat

		std::vector&lt;cx_mat&gt; V = {A, B, C};
		cx_mat T2 = tensor(V); // tensor product of A,B,C
		
		cx_mat T3 = tensor({A, B, C}); // same as above  
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	<hr><br>



	  <a name="tensor_pow"></a>
	  <b>tensor_pow(A, n)</b><br>
	  <ul>
	    <li>Tensor product power of a matrix.</li>
	    <li>Returns <i>A<sup>&otimes;n</sup></i> .</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="dsum"></a>
	  <b>dsum(A, B, ...)</b><br>
	  <ul>
	    <li>Direct sum of arbitrary no. of matrices <code>A,B,...</code>. Return type is deduced from the types of input matrices.</li>
	    <li> Can also take <code>std::vector</code> and 
	    <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of matrices.</li>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5); // complex matrix 
		cx_mat B = randn&lt;cx_mat&gt;(4, 4); // complex matrix
		cx_mat C = randn&lt;cx_mat&gt;(3, 3); // complex matrix
		mat D = randn&lt;mat&gt;(6, 6);       // real matrix
		
		cx_mat T1 = dsum(A, B, C, D); // direct sum of A, B, C, D
		                              // return type is deduced to be cx_mat

		std::vector&lt;cx_mat&gt; V = {A, B, C}; 
		cx_mat T2 = dsum(V); // direct sum of A, B, C
		
		cx_mat T3 = dsum({A, B, C}); // same as above
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="dsum_pow"></a>
	  <b>dsum_pow(A, n)</b><br>
	  <ul>
	    <li>Direct sum power of a matrix.   </li>
	    <li>Returns <i>A<sup>&oplus;n</sup></i> .</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="absm"></a>
	  <b>absm(A)</b><br>
	  <ul>
	    <li>Matrix absolute value of a square matrix.</li>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li>
	    <li>Returns <code>sqrtm_sym(A.t()*A)</code>. Return type is same as that of <code>A</code>.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	<hr><br>


	  <a name="schatten"></a>
	  <b>schatten(A, p)</b><br>
	  <ul>
	    <li>Schatten p-norm of a matrix.</li>
	    
	    <li> <code>p</code> has to be greater than or equal to <i>0</i>.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="purify"></a>
	  <b>purify(A)<br>purify(A, tol)</b><br>
	  <ul>
	    <li> Minimal purification of a density matrix. Returns <code>vec</code> or <code>cx_vec</code> depending on the
	    type of <code>A</code>.</li>
	    
	    <li> <code>tol</code> is optional. By default, <code>tol</code> is equal to the floating point precision used in QIClib.
	    See  <a href="#macro">preprocessor macros in QIClib</a> for details.
	    Eigenvalues (of <code>A</code>) less than <code>tol</code> are treated zero.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	<a name="gram_schmidt"></a>
	  <b>gram_schmidt(A)<br>gram_schmidt(A, normalize = true)</b><br>
	  <ul>
	    <li> Modified Gram-Schmidt orthogonalization.</li>
		 <li> <code>A</code> can be either a matrix (<code>mat</code> or <code>cx_mat</code>) or 
		  <code>std::vector</code>/<code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of vectors 
		  (<code>vec</code> or <code>cx_vec</code>).    
	    
	    <li> <code>normalize</code> is optional. By default, it is <code>true</code>. If it is <code>false</code> then 
	    orthogonal vectors will not be normalized.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="conv_to_pure"></a>
	  <b>conv_to_pure(A)</b><br>
	  <ul>
	    <li>To convert density matrix of a pure state to a column vector
	    (<code>vec</code> or <code>cx_vec</code>).</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li>
	      
	    <li> If <code>A</code> is a column vector, then it is returned back unchanged. </li>
	    
	    <li> If <code>A</code> is not a pure state, then eigenvector corresponding to highest eigenvalue is returned. 
	      To make sure, use <code><a href="#is_pure">is_pure</a></code> function first.</li>
	      
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="std_to_HS"></a>
	  <b>std_to_HS(A)</b><br>
	  <ul>
	    <li>To convert 2-qubit density matrix from the standard basis to the Hilbert-Schmidt (or Pauli) basis.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) of 4x4.</li>
	   
	    <li> Always returns a 4x4 fixed size real matrix (<code>mat44</code>).</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="HS_to_std"></a>
	  <b>HS_to_std(A)</b><br>
	  <ul>
	    <li>To convert 2-qubit density matrix from the Hilbert-Schmidt (or Pauli) basis to the standard basis.</li>
	    
	    <li> <code>A</code> has to be a real square matrix (<code>mat</code>) of 4x4.</li>
	    
	    <li> Always returns a 4x4 fixed size complex matrix (<code>cx_mat44</code>).</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="mket"></a>
	  <b>mket(mask) <br>
	    mket&lt;ELEM_TYPE&gt;(mask) <br> 
	    mket(mask, dim) <br>
	    mket&lt;ELEM_TYPE&gt;(mask, dim)</b><br>
	  <ul>
	    <li> To create multipartite qudit pure state in standard computational basis according to the <code>uvec</code> <code>mask</code>. 
	    (See following example).</li>
	    
	    <li> <code>ELEM_TYPE</code> is optional, by default, it is <code>double</code>. It specifies the element type of 
	      returned column vector. <code>ELEM_TYPE</code> can be <i>real</i> or <i>complex</i> types.</li>
	      
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) 
	    or <code>uvec</code> containing dimensions of every subsystem. 
	     When it is unsigned integer type, all subsystems are supposed to have same dimensions (equal to <code>dim</code>). By default,
	      it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of 
	      every subsystem.</li>
	    <li>Example:
	      <pre>
		vec A = mket({0, 0, 1}); // |001&gt; state
		                         // each subsystem is qubit

		cx_vec B = mket&lt;complex&lt;double&gt; &gt;({0, 0, 1}); // same a above
		                                              // but complex vector returned
		
		vec C = mket({0, 0, 1}, 2); // same a above
		
		vec D = mket({0, 2, 1}, {2, 3, 2}); //|021&gt; state
		                                    // 1st and 3rd party are qubit
		                                    // 2nd one is qutrit

		cx_vec E = mket&lt;complex&lt;double&gt; &gt;({0, 2, 1},{2, 3, 2}); //same as above
		                                                        // but complex vector returned
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="mproj"></a>
	  <b>mproj(mask) <br>
	    mproj&lt;ELEM_TYPE&gt;(mask) <br> 
	    mproj(mask, dim) <br>
	    mproj&lt;ELEM_TYPE&gt;(mask, dim)</b><br><br>
	  <ul>
	    <li>To create multipartite qudit projectors in standard computational basis according to the <code>uvec</code> 
	    <code>mask</code>  (See following example).</li>
	    
	    <li> <code>ELEM_TYPE</code> is optional, by default, it is <code>double</code>. It specifies the element type of 
	      returned matrix. <code>ELEM_TYPE</code> can be <i>real</i> or <i>complex</i> types.</li>
	      
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. 
	      When it is unsigned integer type, all subsystems are supposed to have same dimensions (equal to <code>dim</code>). 
	      By default, it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing 
	      dimensions of 
	      every subsystem.</li>
	      
	    <li>Example:
	      <pre>
		mat A = mproj({0, 0, 1}); // |001&gt;&lt;001| projector
		                          // each subsystem is qubit

		cx_mat B = mproj&lt;complex&lt;double&gt; &gt;({0, 0, 1}); // same a above
		                                               // but complex matrix returned
		
		mat C = mproj({0, 0, 1}, 2); // same a above
		
		mat D = mproj({0, 2, 1}, {2, 3, 2}); //|021&gt;&lt;021| projector
		                                     // 1st and 3rd party are qubit
		                                     // 2nd one is qutrit

		cx_mat E = mproj&lt;complex&lt;double&gt; &gt;({0, 2, 1},{2, 3, 2}); //same as above
		                                                         // but complex matrix returned
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="randU"></a>
	  <b>randU&lt;ELEM_TYPE = double&gt;(range = {0, 1}) <br>
	    randU&lt;VEC_TYPE = vec&gt;(n_elem, range = {0, 1}) <br>
	    randU&lt;MAT_TYPE = mat&gt;(n_rows, n_cols, range = {0, 1})
	  </b><br>
	  <ul>
	    <li>To generate object with uniform random values in the range specified by the <i>column vector</i> <code>range</code>. 
	    By default, the range is in between <code>0</code> to <code>1</code>.</li>

	    <li> The first functions generate only one random element of type (<i>real</i> or <i>complex</i>) specified by 
	    <code>ELEM_TYPE</code>. By default, <code>TYPE</code> is <code>double</code>.</li>

	    <li> The second functions generate a row or column vector of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>VEC_TYPE</code>, with <code>n_elem</code> number of elements. By default, <code>VEC_TYPE</code> is 
	      <code>vec</code>.</li>


	    <li> The third function generates a matrix of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>MAT_TYPE</code>, with <code>n_rows</code> number of rows, <code>n_cols</code> number of columns. 
	      By default, <code>MAT_TYPE</code> is <code>mat</code>.</li>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed, use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li>


	    <li>Example:
	      <pre>
		double a = randU(); // random number between 0 and 1
		
		complex&lt;double&gt; b = randU&lt;complex&lt;double&gt; &gt;();  // complex random number 
		                                                // between (0,0) and (1,1)
		
		double c = randU({-5, 5}); // random number between -5 and 5
		
		cx_vec V = randU&lt;cx_vec&gt;(10); // cx_vec with 10 elements 

		cx_rowvec R = randU&lt;cx_rowvec&gt;(10, {-5, 5}); // cx_rowvec with 10 elements

		mat M1 = randU(10, 10); // 10x10 mat

		mat M2 = randU(10, 10, {-5, 5}); // 10x10 mat  

		cx_mat M3 = randU&lt;cx_mat&gt;(10, 10, {-5, 5}); // 10x10 cx_mat  
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="randN"></a>
	  <b>randN&lt;ELEM_TYPE = double&gt;(mean_sd = {0, 1}) <br>
	    randN&lt;VEC_TYPE = vec&gt;(n_elem, mean_sd = {0, 1}) <br>
	    randN&lt;MAT_TYPE = mat&gt;(n_rows, n_cols, mean_sd = {0, 1})
	  </b><br>
	  <ul>
	    <li>To generate object with random values from normal distribution with mean and standard deviation specified by the 
	      <i>column vector</i> <code>mean_sd</code>. By default, the mean and standard deviation are <code>0</code> and <code>1</code> 
	      respectively.</li>

	    <li> The first function generate only one random element of type (<i>real</i> or <i>complex</i>) specified by 
	    <code>ELEM_TYPE</code>. By 
      default <code>TYPE</code> is <code>double</code>.</li>

	    <li> The second function generate a row or column vector of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>VEC_TYPE</code>, with <code>n_elem</code> number of elements. By default, <code>VEC_TYPE</code> is 
	      <code>vec</code>.</li>


	    <li> The third function generate a matrix of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>MAT_TYPE</code>, with <code>n_rows</code> number of rows, <code>n_cols</code> number of columns. 
	      By default, <code>MAT_TYPE</code> is <code>mat</code>.</li>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed, use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li>


	    <li>Example:
	      <pre>
		double a = randN(); // random number from a normal distribution 
		                    // with mean 0 and sd 1
		
		complex&lt;double&gt; b = randN&lt;complex&lt;double&gt; &gt;(); // complex random number 
		                                               // from a normal distribution 
		                                               // with mean 0 and sd 1
		
		double c = randN({-5, 5}); // random number from a normal distribution 
		                           // with mean -5 and sd 5
		
		cx_vec V = randN&lt;cx_vec&gt;(10); // cx_vec with 10 elements 

		cx_rowvec R = randN&lt;cx_rowvec&gt;(10, {-5, 5}); // cx_rowvec with 10 elements

		mat M1 = randN(10, 10); // 10x10 mat

		mat M2 = randN(10, 10, {-5, 5}); // 10x10 mat  

		cx_mat M3 = randN&lt;cx_mat&gt;(10, 10, {-5, 5}); // 10x10 cx_mat  
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="randI"></a>
	  <b>randI&lt;ELEM_TYPE = sword&gt;(range = {0, 1000}) <br>
	    randI&lt;VEC_TYPE = ivec&gt;(n_elem, range = {0, 1000}) <br>
	    randI&lt;MAT_TYPE = imat&gt;(n_rows, n_cols, range = {0, 1000})
	  </b><br>
	  <ul>
	    <li>To generate object with uniform random integers in the range specified by the <i>column vector</i> <code>range</code>. 
	    By default, the range is 
	      in between <code>0</code> to <code>1000</code>.</li>

	    <li> The first function generates only one random integer of type (<i>real</i> or <i>complex</i>) 
	    specified by <code>ELEM_TYPE</code>. By 
	      default <code>TYPE</code> is <code><a href = "http://arma.sourceforge.net/docs.html#uword">sword</a></code>.</li>

	    <li> The second function generates a row or column vector of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>VEC_TYPE</code>, with <code>n_elem</code> number of elements. By default, <code>VEC_TYPE</code> is 
	      <code>ivec</code>.</li>


	    <li> The third function generates a matrix of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>MAT_TYPE</code>, with <code>n_rows</code> number of rows, <code>n_cols</code> number of columns. 
	      By default, <code>MAT_TYPE</code> is <code>imat</code>.</li>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed, use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li>


	    <li>Example:
	      <pre>
		sword a = randI(); // random integer (arma::sword) between 0 and 10000
		int a1 = randI&lt;int&gt;(); // random integer (int) between 0 and 10000

		
		complex&lt;double&gt; b = randI&lt;complex&lt;double&gt; &gt;(); // complex random integer 
		                                               // (type-casted to complex&lt;double&gt;) 
		                                               // between (0,0) and (1000,1000)
		
		sword c = randI({-100, 100}); // random integer (arma::sword) between -100 and 100
		
		ivec V = randI(10); // ivec with 10 elements 

		irowvec R = randI&lt;irowvec&gt;(10, {-100, 100}); // irowvec with 10 elements

		imat M1 = randI(10, 10); // 10x10 imat

		mat M2 = randI&lt;mat&gt;(10, 10, {-100, 100}); // 10x10 mat  
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="randHermitian"></a>
	  <b>randHermitian&lt;ELEM_TYPE = complex&lt;double&gt; &gt;(dim)
	  </b><br>
	  <ul>
	    <li>To generate random Hermitian (<code>cx_mat</code>) or real symmetric matrix (<code>mat</code>). 
	      <code>dim</code> is an <i>unsigned integer</i> 
	      (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>) specifying the dimension of the matrix.</li>

	    <li> <code>ELEM_TYPE</code> specifies the element type of the matrix (<i>complex (or real) floating point</i> type). 
	    By default, it is <code>complex&lt;double&gt</code>. If <code>ELEM_TYPE</code> is real number (<code>double</code>)
	    the function generates random real symmetric matrix.</li>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed, use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li>


	    <li>Example:
	      <pre>
		cx_mat H1 = randHermitian(10); // 10x10 Hermitian cx_mat

		mat H2 = randHermitian&lt;double&gt;(10); // 10x10 real symmetric matrix
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name="randUnitary"></a>
	  <b>randUnitary&lt;ELEM_TYPE = complex&lt;double&gt; &gt;(dim)
	  </b><br>
	  <ul>
	    <li>To generate random unitary (<code>cx_mat</code>) or real orthogonal matrix (<code>mat</code>), 
	    uniformly distributed according to the Haar measure.
	      <code>dim</code> is an <i>unsigned integer</i> (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>) 
	      specifying the dimension of the matrix.</li>

	    <li> <code>ELEM_TYPE</code> specifies the element type of the matrix (<i>complex (or real) floating point</i> type). 
	    By default, it is <code>complex&lt;double&gt</code>. If <code>ELEM_TYPE</code> is real number (<code>double</code>)
	    the function generates random real orthogonal matrix.</li>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed, use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li><br>


	    <li>Example:
	      <pre>
		cx_mat U1 = randUnitary(10); // 10x10 Unitary cx_mat

		mat U2 = randUnitary&lt;double&gt;(10); // 10x10 real orthogonal matrix
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="randPsi"></a>
	  <b>randPsi&lt;ELEM_TYPE = complex&lt;double&gt; &gt;(dim)
	  </b><br>
	  <ul>
	    <li>To generate random pure states (<code>cx_vec</code> or <code>vec</code>), uniformly distributed according to the Haar measure.
	      <code>dim</code> is an <i>unsigned integer</i> (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>)
	       specifying the dimension of the state.</li>

	    <li> <code>ELEM_TYPE</code> specifies the element type of the matrix (<i>complex (or real) floating point</i> type). 
	    By default, it is <code>complex&lt;double&gt</code>.</li>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed, use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li>

	    <li>Example:
	      <pre>
		cx_vec psi1 = randPsi(10); // pure state (cx_vec) of dimension 10

		vec psi2 = randPsi&lt;double&gt;(10); // real pure state (vec) 
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="randPerm"></a>
	  <b>randPerm(n, start = 0)
	  </b><br>
	  <ul>
	    <li>To generate random permutation of <i>unsigned</i> (positive) integers of size <code>n</code>. Returns a 
	    <code>uvec</code>.</li>

	    <li> <code>start</code> (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>) is optional. 
	    It specifies starting point of the permutation. By default, it is 0.</li>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed, use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li>

	    <li>Example:
	      <pre>
		uvec perm1 = randPerm(5); // random permutation of {0,1,2,3,4}
		
		uvec perm2 = randPerm(5, 2); // random permutation of {2,3,4,5,6}
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="entropy"></a>
	  <b>entropy(A)</b><br>
	  <ul>
	    <li>von Neumann entropy of a quantum state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li>
	      
	    <li> If <code>A</code> is a column vector, return value is always zero. </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="shannon"></a>
	  <b>shannon(V)</b><br>
	  <ul>
	    <li>Shannon entropy of a probability distribution.</li>
	    
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code> or <code>std::vector</code> of 
	    positive real numbers).</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="renyi"></a>
	  <b>renyi(A, a)</b><br>
	  <ul>
	    <li>Renyi entropy of a quantum state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>), and <code>a</code> has to to greater than or equal to zero.</li>
	      
	    <li> If <code>A</code> is a column vector, return value is always zero. </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="renyi_prob"></a>
	  <b>renyi_prob(V, a)</b><br>
	  <ul>
	    <li>Renyi entropy of a probability distribution.</li>
	    
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code> or <code>std::vector</code> of positive 
	      real numbers), and <code>a</code> has to to greater than or equal to zero.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="tsallis"></a>
	  <b>tsallis(A, a)</b><br>
	  <ul>
	    <li>Tsallis entropy of a quantum state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>), and <code>a</code> has to to greater than or equal to zero.</li>
	      
	    <li> If <code>A</code> is a column vector, return value is always zero. </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="tsallis_prob"></a>
	  <b>tsallis_prob(V, a)</b><br>
	  <ul>
	    <li>Tsallis entropy of a probability distribution.</li>
	    
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code> or <code>std::vector</code> of positive 
	      real numbers), and <code>a</code> has to to greater than or equal to zero.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="mutual_info"></a>
	  <b>mutual_info(A, dim) <br> 
	    mutual_info(A, subsys1, subsys2)<br> 
	    mutual_info(A, subsys1, subsys2, dim)</b><br>
	  <ul>
	    <li> Quantum mutual information between 2 subsystems of a quantum state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li>

	    <li> In the first case, <code>dim</code> has to be a <code>uvec</code> of two elements, 
	    containing the dimensions of two subsystems.</li>

	    <li> In the second case, <code>dim</code> is optional. It can be either <i>unsigned integer</i> type
	     (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> 
	      containing dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	      (equal to <code>dim</code>). By default, it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> 
	      as a <code>uvec</code> containing dimensions of every subsystem.
	      <code>subsys1</code> and <code>subsys1</code> are  <code>uvec</code> containing the indices parties that constitute 
	      of 1st partition and 2nd partition respectively.
	    </li>
	    
	    <li> Indices in <code>subsys1</code> and <code>subsys2</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li>  
	    <li> Example:
	      <pre>
		
		cx_mat A = randRho(12); // 12x12 density matrix
		
		cx_mat B = randRho(16); // 16x16 density matrix

		// mutual_info between two parties with dim 4 and 3
		double A1 = mutual_info(A, {4, 3}); // 1st party has dim=4,
		                                    // 2nd party has dim=3

		// mutual_info between 1,3 and 2,4 parties
		double B1 = mutual_info(B, {1, 3}, {2, 4});

		double B2 = mutual_info(B, {1, 3}, {2, 4}, 2); //same as above
		                                               // all party has dim = 2

		double B1 = mutual_info(B, {1, 3}, {2, 4}, {2, 2, 2, 2}); // same as above
		                                                          // explicitly written dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


    <a name="rel_entropy"></a>
	  <b>rel_entropy(A, B)</b><br>
	  <ul>
	    <li>Relative entropy of between two quantum state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>). Same for <code>B</code>.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="rel_entropy_prob"></a>
	  <b>rel_entropy_prob(V1, V2)</b><br>
	  <ul>
	    <li>Relative entropy of between two probability distribution.</li>
	    
	    <li> <code>V1</code> and <code>V2</code> have to be positive real column vectors of same type (<code>vec</code> or 
	    <code>std::vector</code> of positive real numbers).</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="entanglement"></a>
	  <b>entanglement(A, dim)</b>
	  <ul>
	    <li>Entanglement entropy of a pure quantum state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>), and <code>dim</code> has to be a <code>uvec</code> of two elements, 
	      containing the dimensions of two subsystems..</li>
	      
	    <li> If <code>A</code> is a square matrix and not a density matrix of a pure state, then von Neumann entropy of traced out 
	      2nd party density matrix is returned. To make sure use <code><a href="#is_pure">is_pure</a></code> function first. </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="neg"></a>
	  <b>neg(A, subsys) <br> neg(A, subsys, dim) </b><br>
	  <ul>
	    <li> Negativity of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of 
	    transposed subsystems.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>
	      
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>
	      
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the 
	      index <i>2</i> and so on.</li>
	        
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix
		
		cx_mat B = randRho(12); // 12x12 density matrix
		
		// negativity by transposing 2nd and 3rd party
		double A1 = neg(A, {2, 3}); // all dim are 2, total 3 parties

		// negativity by transposing 2nd and 3rd party
		double B1 = neg(B, {2, 3}, {2, 3, 2}); // explicitly written dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="log_neg"></a>
	  <b>log_neg(A, subsys) <br> log_neg(A, subsys, dim) </b><br>
	  <ul>
	    <li> Logarithmic negativity of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices 
	      of transposed subsystems.</li>
	      
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>
	      
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
       If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
       containing dimensions of every subsystem.</li>
	    
  	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index 
	      <i>2</i> and so on.</li> 
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix

		cx_mat B = randRho(12); // 12x12 density matrix

		// logarithmic negativity by transposing 2nd and 3rd party
		double A1 = log_neg(A, {2, 3}); // all dim are 2, total 3 parties

		// logarithmic negativity by transposing 2nd and 3rd party
		double B1 = log_neg(B, {2, 3}, {2, 3, 2}); // explicitly written dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="concurrence"></a>
	  <b>concurrence(A) </b><br>
	  <ul>
	    <li> Concurrence of a two-qubit quantum state.</li>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) of dimension 4.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="EoF"></a>
	  <b>EoF(A) </b><br>
	  <ul>
	    <li> Entanglement of formation of a two-qubit quantum state.</li>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector  
	      (<code>vec</code> or <code>cx_vec</code>) of dimension 4.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="ent_check_CMC"></a>
	  <b>ent_check_CMC(A, dim) <br > ent_check_CMC(A, dim1, dim2) </b><br><br>
	  <ul>
	    <li> To check if a bipartite state is entangled or not (based on covariant matrix criteria (<i>Phys. Rev. A <b>78</b>, 052319 (2008),
	    Proposition IV.2</i>), 
	    can be used to detect bound entangled states)</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li>
	    
	    <li> Returns <code>true</code> if <code>A</code> is entangled, else <code>false</code>. </li>
	    
	    <li> The first form assumes both the subsystems have same dimension. <code>dim</code> is an unsigned integer type
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) stating the 
	      dimensions of both the subsystems.</li>
	      
	    <li> The second case applies if the subsystems have different  dimensions. <code>dim1</code> and <code>dim2</code> are unsigned 
	      integer types (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) stating the dimensions of 
	      1st and 2nd party respectively.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>



	  <a name="schmidt"></a>
	  <b>vec S = schmidt(A, dim) <br > schmidt(A, dim, S, U, V) <br>
	  schmidt_full(A, dim, S, U, V) </b><br>
	  <ul>
	    <li> Schmidt decomposition of a bipartite pure state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>
	      
	    <li> <code>dim</code> is a <code>uvec</code> of two elements, containing dimensions of each party.</li>
	    
	    <li> <code>S</code> is a real vector containing Schmidt coefficients. <code>U</code> and <code>V</code> are matrices that 
	      store Schmidt vectors column-wise, such that <code>A = &Sigma;<sub>i</sub> S(i) * kron(U.col(i), V.col(i))</code>.</li>

		 <li>	<code>schmidt_full</code> gives full Schmidt basis on both sides (i.e., <code>U</code> and <code>V</code>).</li>      
	      
	    <li> If <code>A</code> is a square matrix, then it is translated into a column vector using 
	      <code><a href="#conv_to_pure">conv_to_pure</a></code>.</li>
	      
	    <li> If decomposition fails then <code>vec S = schmidt(A,dim)</code> throws <code>std::runtime_error</code> exception, 
	      and <code>schmidt(A,dim,S,U,V)</code> and <code>schmidt_full(A,dim,S,U,V)</code> returns <code>false</code> and 
	      resets <code>S</code>, <code>U</code>, and <code>V</code>.</li>
	    <li> Example:
	      <pre>
		cx_vec A = randPsi(8); // 8 dimensional pure state

		vec S1 = schmidt(A, {2, 4});

		vec S;
		cx_mat U,V;
		schmidt(A, {2, 4}, S, U, V);
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="schmidt_base"></a>
	  <b>schmidtA(A, dim) <br > schmidtA_full(A, dim) <br>
	    schmidtB(A, dim) <br > schmidtB_full(A, dim)<br>
	    schmidtAB(A, dim) <br > schmidtAB_full(A, dim)</b><br>
	  <ul>
	    <li> Schmidt vectors of a bipartite pure state.</li>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li>
	      
	    <li> <code>dim</code> is a <code>uvec</code> of two elements, containing dimensions of each party.</li>
	    
	    <li> If <code>A</code> is a square matrix, then it is translated into a column vector using 
	    <code><a href="#conv_to_pure">conv_to_pure</a></code>.</li>
	    
	    <li> <code>schmidtA(A,dim)</code> returns truncated Schmidt basis on Alice's side in a column-wise manner, while 
	      <code>schmidtA_full(A,dim)</code> returns full Schmidt basis on Alice's side.</li>
	      
	    <li> <code>schmidtB(A,dim)</code> returns truncated Schmidt basis on Bob's side in a column-wise manner, 
	      while <code>schmidtB_full(A,dim)</code> returns full Schmidt basis on Bob's side.</li>
	      
	    <li> <code>schmidtAB(A,dim)</code> returns <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of 
	      matrices containing truncated Schmidt basis on both sides in a column-wise manner, while <code>schmidtAB_full(A,dim)</code> 
	      returns <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of matrices containing full Schmidt 
	      basis on both side.</li>
	      
	    <li> If decomposition fails then these functions throw <code>std::runtime_error</code> exception.</li>
	    <li> Example:
	      <pre>
		cx_mat A = randPsi(8); // 8 dimensional pure state
		
		cx_mat V = schmidtB(A, {2, 4}); // V is 4x2 matrix
		
		cx_mat Vf = schmidtB_full(A, {2, 4}); // Vf is 4x4 matrix

		field&lt;cx_mat&gt; AB = schmidtAB(A, {2, 4});
		//AB(0) == Schmidt basis on Alice's side
		//AB(1) == Schmidt basis on Bob's side
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	<a name="l1_coh"></a>
	  <b>l1_coh(A)<br>l1_coh(A, U)</b><br>
	  <ul>
	    <li> l1-norm coherence of a quantum state.</li>
		 <li> <code>A</code> can be either a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
		  (<code>vec</code> or <code>cx_vec</code>).    
	    
	    <li> <code>U</code> is a Unitary matrix (<code>mat</code> or <code>cx_mat</code>) to rotate the state for obtaining 
	    	coherence with respect to the desired basis.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	<a name="rel_entropy_coh"></a>
	  <b>rel_entropy_coh(A)<br>rel_entropy_coh(A, U)</b><br>
	  <ul>
	    <li> Relative entropy of coherence of a quantum state.</li>
		 <li> <code>A</code> can be either a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
		  (<code>vec</code> or <code>cx_vec</code>).    
	    
	    <li> <code>U</code> is a Unitary matrix (<code>mat</code> or <code>cx_mat</code>) to rotate the state for obtaining 
	    	coherence with respect to the desired basis.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="HS_dist"></a>
	  <b>HS_dist(A, B) </b><br>
	  <ul>
	    <li> Hilbert-Schmidt distance between two density matrices.</li>
	    <li> <code>A</code> and <code>B</code> have to be square matrices 
	    (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="tr_dist"></a>
	  <b>tr_dist(A, B) </b><br>
	  <ul>
	    <li> Trace distance between two density matrices.</li>
	    <li> <code>A</code> and <code>B</code> have to be square matrices 
	    (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="bures_dist"></a>
	  <b>Bures_dist(A, B) </b><br>
	  <ul>
	    <li> Bures distance between two density matrices.</li>
	    <li> <code>A</code> and <code>B</code> have to be square matrices 
	    (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="fidelity"></a>
	  <b>fidelity(A, B) </b><br>
	  <ul>
	    <li> Fidelity between two density matrices.</li>
	    <li> <code>A</code> and <code>B</code> have to be square matrices 
	    (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="apply"></a>
	  <b> apply(A, U, subsys) 
	  <br> apply(A, U, subsys, dim) 
	  <br> apply(A, Ks, subsys, dim) 
	  <br> apply(A, Ks)</b><br>
	  <ul>
	    <li>To apply a quantum gate <code>U</code> or a set of Kraus operators <code>Ks</code>to a quantum state <code>A</code>.</li>

	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>

		
		<li> <code>U</code> has to a square matrix (<code>mat</code> or <code>cx_mat</code>), and <code>Ks</code> can be a 
	    <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> or a <code>std::vector</code> of
	    square matrices (<code>mat</code> or <code>cx_mat</code>) having same dimensions.</li>

	    
	    <li> In the first three cases, <code>subsys</code> is a <code>uvec</code> containing the indices of subsystems, where the gate
	    or the Kraus operators will be applied.</li>
	    
	    
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index 
	      <i>2</i> and so on.</li>
	    
	    <li> In the first three cases, the dimension of the gate <code>U</code> or the Kraus operators <code>Ks</code> must match the 
	    dimension of subsystems specified in <code>subsys</code>.</li>

	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>

		<li> In the last case, the set of Kraus operators <code>Ks</code> acts on the whole quantum state <code>A</code>. 
		      The dimension of the Kraus operators <code>Ks</code> must match the dimension of the quantum state <code>A</code>.</li>
	      
	    <li> <b>Note:</b> Return type is deduced from the element types of <code>A</code> and <code>U</code>/<code>Ks</code>. 
	    For simplicity use <code>auto</code> to deduce the return type.</li>
	      
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix
		cx_mat B = randRho(2); // 2x2 density matrix

		const mat& U1 = spm.S(1); // \sigma_x gate
		cx_mat U2 = kron(spm.S(1),spm.S(1)); // kron(\sigma_x,\sigma_x) gate 

		vector&lt;cx_mat&gt; BF = {(1 - 0.25) * spm.S(0), 0.25 * spm.S(1)};
		// Kraus operators for Bit-Flip channel with p = 0.25 
					
		cx_mat A1 = apply(A, U1, {2}); // all dim are 2, total 3 parties
		cx_mat A2 = apply(A, U2, {1, 3}, {2, 2, 2}); // explicitly written dimensions
		
		cx_mat A3 = apply(A, BF, {2}, {2, 2, 2}); // apply Bit-Flip on 2nd party
		
		cx_mat B1 = apply(B, BF); // apply Bit-Flip on B
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="apply_ctrl"></a>
	  <b>apply_ctrl(A, U, ctrl, subsys) <br> apply_ctrl(A, U, ctrl, subsys, dim) </b><br>
	  <ul>
	    <li> To apply a quantum gate <code>U</code> to a quantum state <code>A</code> as a controlled gate. 
	    <code>subsys</code> is a <code>uvec</code> 
	      containing the indices subsystems, where the gate will be applied, and <code>ctrl</code> is a <code>uvec</code> 
	      containing the indices of control subsystems.</li>
	      
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>
	      
	    <li> <code>U</code> to has be a square matrix (<code>mat</code> or <code>cx_mat</code>) and the
	    dimension of gate <code>U</code> must match the dimension of subsystems specified in <code>subsys</code>.</li>
	    
	    <li> All control subsystems must have same dimensions.</li>
	    
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>

	    <li> Indices in <code>subsys</code> and <code>ctrl</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li>
	        
	    <li> <b>Note:</b> Return type is deduced from the element types of <code>A</code> and <code>U</code>. For simplicity use
	      <code>auto</code> to deduce the return type.</li>
	      
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix

		const mat& U1 = gates.X; // \sigma_x gate
		
		mat U2 = kron(gates.X, gates.X); // kron(\sigma_x,\sigma_x) gate 

		cx_mat A1 = apply_ctrl(A, U1, {1}, {2}); // all dim are 2, total 3 parties

		cx_mat A2 = apply_ctrl(A, U2, {2}, {1, 3}, {2, 2, 2}); // explicitly written dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>


	  <a name="make_ctrl"></a>
	  <b>make_ctrl(U, ctrl, subsys, n, dim = 2) <br> make_ctrl(U, ctrl, subsys, dim)</b><br>
	  <ul>
	    <li> To convert a quantum gate <code>U</code> into a controlled quantum gate. 
	    <code>subsys</code> is a <code>uvec</code> 
	      containing the indices subsystems, where the gate will be applied, and <code>ctrl</code> is a <code>uvec</code> 
	      containing the indices of control subsystems.</li>
	      
	   <li> <code>U</code> to has be a square matrix (<code>mat</code> or <code>cx_mat</code>) and the
	    dimension of gate <code>U</code> must match the dimension of subsystems specified in <code>subsys</code>.</li>	    
	    
	    <li> All control subsystems must have same dimensions.</li>
	    
	    <li> In the first case, <code>n</code> is a <code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>
	    mentioning total number of subsystems, having same dimensions equal to <code>dim</code> 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>). 
	    By default, <code>dim</code> is 2.</li>
	    
	    <li> In the second case, <code>dim</code> is a <code>uvec</code> containing 
	    dimensions of every subsystem. These form is needed if different subsystems have different dimensions.
	    </li>

	    <li> Indices in <code>subsys</code> and <code>ctrl</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li>
	      
	    <li> Example:
	      <pre>
		const mat& U = gates.X; // \sigma_x gate
		
		mat CU1 = make_ctrl(U, {1}, {2}, 2); // make two-party controlled X gate
		                                     // where 1st party is control and
		                                     // second party is target.
		                                     // Here, n = 2 and 
		                                     // dim = 2 (by default)

		mat CU2 = make_ctrl(U, {1}, {2}, {2, 2}); //same as above 
		                                          // explicitly written dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="measure"></a>
	  <b>std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; result = measure(cx_mat A, Ks) <br> 
	    std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; result = measure(mat A, Ks) <br>
	    std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; result = measure(cx_mat A, Ks, subsys, dim)<br> 
	    std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; result = measure(mat A, Ks, subsys, dim)
	  </b>
	  <br>
	  <ul>
	    <li>To measure a quantum state <code>A</code> using a set of Kraus or projection operators <code>Ks</code>. 
	    Returns <code>std::tuple</code> of: 1. result of the measurement 
	    (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>), 
	      2. vector of outcome probabilities (<code>vec</code>), 
	      and 3. <code><a href = "http://arma.sourceforge.net/docs.html#field">
		  field</a></code> of post-measurement normalized states (<code>field&lt;cx_mat&gt;</code> or <code>field&lt;mat&gt;</code>).</li>

	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>

	    <li> <code>Ks</code> can be a <code>std::vector</code>  or a 
	      <code><a href = "http://arma.sourceforge.net/docs.html#field">
		  field</a></code> of Kraus or projection operators (either <code>cx_mat</code>, <code>mat</code>, <code>cx_vec</code> or 
	      <code>vec</code>). It can also be a <code>cx_mat</code> or <code>mat</code>, where each column will be treated as projection 
	      operators.</li>

	    <li> First two functions measure the whole quantum state <code>A</code>, and the dimension of the operators in <code>Ks</code> 
	      must match the dimension of <code>A</code>.</li>

	    <li> Last two functions partially measure the subsystems of the state <code>A</code>. The indices of measured subsystems
	     are specified in <code>subsys</code> (<code>uvec</code>).    
	      The dimension of the operators in <code>Ks</code> must match the dimension of subsystems specified 
	      in <code>subsys</code>.</li>

	    <li> All Kraus or projection operators must have same dimensions.</li>

	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>


	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li>

	    <li> <b>Note:</b> <code>MATRIX_TYPE</code> is deduced from the element types of <code>A</code> and <code>Ks</code>. 
	    For simplicity use
	      <code>auto</code> to deduce return type.</li>
	    <li> Example:
	      <pre>
		cx_mat A1 = randRho(2); // 2x2 random density matrix

		std::vector<cx_mat> Ks = {spm.basis2(0,1), spm.basis2(1,1)};
		  // std::vector of projection operators in \sigma_x direction

		auto result1 = measure(A1, Ks); // measurement
		std::get<0>(A); // measurement result
		std::get<1>(A); // outcome probabilities
		std::get<2>(A); // post measurement normalised states
			
		cx_mat A2 = randRho(8); //8x8 random density matrix

		auto result2 = measure(A2, Ks, {2}, {2,2,2}); measure the 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="measure_comp"></a>
	  <b>std::tuple&lt;uword, vec&gt; result = measure_comp(A) <br> 
	    std::tuple&lt;uword, vec&gt; result = measure_comp(A, subsys, dim) 
	  </b>
	  <br>
	  <ul>
	    <li>To measure a quantum state <code>A</code> in the computational basis. Returns <code>std::tuple</code> 
	      of: 1. result of the measurement (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>) 
	      and 2. vector of outcome probabilities (<code>vec</code>).</li>

	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li>

	    <li> The first function measures the whole quantum state, where as the last function partially measures the subsystems of the state 
	      <code>A</code>, where the indices of measured subsystems are specified in <code>subsys</code>.</li>

	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>

	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li>

	    <li> Example:
	      <pre>
		cx_mat A1 = randRho(2); // 2x2 random density matrix

		auto result1 = measure_comp(A1); // measurement
		std::get<0>(A); // measurement result
		std::get<1>(A); //  outcome probabilities
		    
		cx_mat A2 = randRho(8); //8x8 random density matrix

		auto result2 = measure_comp(A2, {2}, {2,2,2}); measure the 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
		




	  <hr><hr>

	  <h3>Classes for Quantum Discord like features</h3>
	  <hr> <br>

		<ul>
	    <li> <b>Note:</b> These features depend on <a href = "http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a>. </li> 
	    <li> <b>Note:</b> If you want to use old API's for discord like function, define <code>QICLIB_USE_OLD_DISCORD</code> macro 
	    before including <code>QIClib</code> header. See  <a href="#macro">preprocessor macros in QIClib</a> for details. Old API's for 
	    discord like functions are not maintained anymore.</li> <br>
		</ul>
	
	<hr>

	  <a name="discord_space"></a>
	  <a name="deficit_space"></a>
	  <b>discord_space&lt;MATRIX_TYPE&gt; <br>
	  deficit_space&lt;MATRIX_TYPE&gt;</b>
	  <br>
	  <ul>
	    <li><code>discord_space</code> provides computational space for calculating quantum discord 
	    (actual as well as constrained-regular, as discussed in <i>Phys. Rev. A 92, 062301 (2015), Sec. III.A, Case 4</i>) 
	    for quantum states when measurement is done over a qubit or qutrit system, <code>deficit_space</code> does the  same for one-way 
	    quantum work deficit. 
	    Both have same syntaxes, so for the demonstration purpose, we will talk about <code>discord_space</code> only.
	    
	    <li>Works for real or complex density matrices (<code>mat</code> or <code>cx_mat</code>). <code>MATRIX_TYPE</code> denotes the 
	    the data type of the density matrix i.e., <code>mat</code> or <code>cx_mat</code>.</li>
	    
	    
	    <li> <b>Constructors:</b> <br> 
	    <code>discord_space&lt;MATRIX_TYPE&gt;(A, subsys, dim)</code> <br>
	    <code>discord_space&lt;MATRIX_TYPE&gt;(A, subsys)</code> <br>
	    <ul>
	    	<li> <code>A</code> is a square matrix of type <code>MATRIX_TYPE</code>.</li>

	    	<li> <code>subsys</code> is a  unsigned integer type 
	    	(<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>), which denotes the index of measured subsystem.
	    	Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li>

	    	<li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.<code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>
		</ul>	    	
	    </li>
	    
	    <li><b>Member functions:</b> <br>
	    <ul>

	    	<li> <code>.result()</code>: Computes quantum discord, and returns the result. This function will keep the value cached in the memory. 
	    	Further use of this function will return the cached value, rather than computing discord all over again.</li>

	    	<li> <code>.result_reg()</code>: Computes constrained-regular quantum discord, and returns the result. 
	    	This function will keep the value cached in the memory. 
	    	Further use of this function will return the cached value, rather than computing constrained-regular quantum 
	    	discord all over again.</li>

	    	<li> <code>.compute()</code>: Computes quantum discord whenever called. This function will rewrite the cached result to
	    	the new one. One can use <code>.result()</code> to get the new value (see the following example).</li>

			<li> <code>.compute_reg()</code>: Computes constrained-regular quantum discord whenever called. This function will rewrite the cached result to
	    	the new one. One can use <code>.result_reg()</code> to get the new value (see the following example).</li>

	    	<li> <code>.reset()</code>: This will reset the state of <code>discord_space</code> to the default settings. All cached values 
	    	will be forgotten.</li>

	    	<li> <code>.reset(subsys)</code>: This will reset the state of <code>discord_space</code> to the default settings. All cached values 
	    	will be forgotten. <code>subsys</code> is a  unsigned integer type 
	    	(<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>), which denotes the index of <b>new</b> 
	    	measured subsystem.
	    	Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li>

	      <li> <code>.reset(A, subsys, dim)</code>: This will reset the state of <code>discord_space</code> to the default settings. All cached values 
	    	will be forgotten. <code>A</code> is the <b>new</b> density matrix (square matrix) of type <code>MATRIX_TYPE</code>.
	    	<code>subsys</code> is a  unsigned integer type 
	    	(<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>), which denotes the index of <b>new</b> 
	    	measured subsystem.
	    	Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on. <code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.<code>dim</code> is optional. It can be either <i>unsigned integer</i> type 
	    (<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>) or <code>uvec</code> containing 
	    dimensions of every subsystem. When it is unsigned integer type, all subsystems are supposed to have same dimensions 
	    (equal to <code>dim</code>). By default, it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subsystem.</li>
	    </ul></li>
	    
	    <li> <b>Helper member functions:</b> These functions are there to change the settings of the optimization processes done 
	    by <a href = "http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a>, to fine tune the result. In general, users can overlook
	    these functions, and default settings will be used.
	    <br>
	    
	    <ul>
			<li> <code>.use_global_opt(bool a = true)</code>: Set whether global optimization will be performed (<code>true</code>) 
			or not (<code>false</code>).</li>
			
			<li> <code>.global_algorithm(nlopt::algorithm a = nlopt::GN_DIRECT_L_RAND)</code>: Set global optimization algorithm.</li>
			
			<li> <code>.global_xtol(double a)</code>: Set global optimization <i>xtol</i>. By default, it is <code>4e-2</code> for
			qubit systems, and <code>0.25</code> for qutrit systems.</li>
			
			<li> <code>.global_ftol(double a = 0)</code>: Set global optimization <i>ftol</i>.</li>

			<li> <code>.local_algorithm(nlopt::algorithm a = nlopt::LN_COBYLA)</code>: Set local optimization algorithm.</li>
			
			<li> <code>.local_xtol(double a)</code>: Set local optimization <i>xtol</i>.</li>
			
			<li> <code>.local_ftol(double a = 0)</code>: Set local optimization <i>ftol</i>.</li>

			<li> <code>.angle_range(const vec& a)</code>: Set the ranges of angles (parameters of unitary matrices) as multiples of &pi;.
			For qubit systems, default is <code>{1, 2}</code>, and for qutrit systems, default is <code>{2, 2, 2, 2, 2}</code>.</li> 
			
			<li> <code>.initial_angle(const vec& a)</code>: Set the initial values of angles as multiples of &pi;.
			For qubit systems, default is <code>{0.1, 0.1}</code>, and for qutrit systems, default is 
			<code>{0.1, 0.1, 0.1, 0.1, 0.1}</code>.</li> 
		 </ul>
	    </li>

	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix (3-qubit)

		// create discord_space, we measure the 2nd party to compute discord
		discord_space<cx_mat> DSpace(A, {2});		
		
		// calculate discord
		double DResult = DSpace.result();

		// change local optimization algorithm,
		// then compute the discord,
		// and get the result in one line --->
		double DResult = DSpace.local_algorithm(nlopt::LN_SBPLX).compute().result().
	
		
		cx_mat B = randRho(12); // new 2x3x2 density matrix
		
		// using same discord_space for new density matrix,
		// measurement on 2nd party (qutrit)
		DSpace.reset(B, {2}, {2, 3, 2});
		
		double new_DResult = Dspace.result(); 

	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><hr>
	  <a name=faq></a>
	  <h3>Frequently asked questions</h3>
	  <hr> <br>

	  <ul>
	    

	    <li> <b> What are the basic dependencies of QIClib?</b><br>
	      <ul>
		<li> <a href="http://arma.sourceforge.net/">Armadillo</a> C++ linear algebra library (<b>version 4.2 or later</b>), with  
		  <a href = "http://www.netlib.org/lapack/">LAPACK</a> and 
		  <a href = "http://www.netlib.org/blas">BLAS</a> implementations.</li>
		<li> A C++11 compliant compiler. <a href="https://gcc.gnu.org/">gcc</a> version 4.8 or later, or 
		  <a href = "http://clang.llvm.org/">clang</a> version 3.3 or later are recommended. </li>
		<li>  <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a> nonlinear optimization library for 
		  certain features. See <a href ="index.html#getting-started"> getting started</a> section.
	      </ul>
	    </li>

	    

	    
	    <li><b>How do I use QIClib in my project?</b><br>
	      See <a href ="index.html#getting-started"> getting started</a> section.
	    </li>
	    


	    
	    <li><b>How do I report bugs?</b><br>
	      See <a href="index.html#found-an-issue-or-bug">this</a>.
	    </li>
	    


	    <li><b>How do I use XYZ function properly?</b><br>
	      See <a href="#top">API documentation</a>. If you still have concerns, see <a href= "index.html#got-a-problem-or-question">this</a>.
	    </li>
	    


	    <li><b>Can you implement certain features, which are useful for my work?</b><br>
	      Yes, see <a href= "index.html#requesting-a-feature">this</a>.
	    </li>
	    


	    
	    

	    <li> <b> Instead of using other popular C++ linear algebra libraries, why did QIClib choose <a href="http://arma.sourceforge.net/">Armadillo</a>?</b>
	      <ul>
		<li> <a href="http://arma.sourceforge.net/">Armadillo</a> is fast, efficient and reliable.</li>
		<li> It has nice API, which is deliberately similar to Matlab.</li>
		<li> It supports modern C++11 features, like move semantics or initialiser list initialization, which indeed increase efficiency and usability.</li>
		<li> It has rapid developement process.</li>
		<li> It can make use of high performance  multi-threaded <a href = "http://www.netlib.org/lapack/">LAPACK</a> and 
		  <a href = "http://www.netlib.org/blas">BLAS</a> replacements like <a href = "http://www.openblas.net/">OpenBLAS</a>, 
		  <a href = "https://software.intel.com/en-us/intel-mkl">Intel MKL</a>, or 
		  <a href = "http://developer.amd.com/tools-and-sdks/archive/amd-core-math-library-acml/"> AMD ACML</a>.</li>
	      </ul>
	    </li>


	    

	    <li><b>I know C++98, but do not know much about C++11. Can I use QIClib?</b><br>
	      Yes. Though QIClib is written in C++11 standard, you can still do C++98 style coding with QIClib functions. 
	      You just need a C++11 compliant compiler and make sure that you add necessary compiler flag to enable C++11 features, 
	      e.g., in <a href="https://gcc.gnu.org/">gcc</a> or <a href = "http://clang.llvm.org/">clang</a> add <code>-std=c++11</code> flag during compilation.
	    </li>
	    

	    
	    <li><b>Can I use C++11 <code>auto</code> with QIClib functions?</b><br>
	      Though use of C++11 <code>auto</code> is not recommended with <a href="http://arma.sourceforge.net/">Armadillo</a> expressions, 
	      due to the extensive use of template meta-programming, every QIClib functions return by value, so use of <code>auto</code> is safe there. 
	      In fact, use of <code>auto</code> is recommended with QIClib functions and objects, as it will always guarantee <i>move</i> operations. 
	      But again, care should be taken when <code>auto</code> is used with <a href="http://arma.sourceforge.net/">Armadillo</a> expressions. 
	      See the following example:<br>
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8);
		A *= A.t();
		A /= trace(A);

		auto B = A; // OK, no temporary expression
		auto C = TrX(A,{1},{2,2,2}); // OK, QIClib function
		auto D = powm_sym(A,3); // OK, QIClib function

		auto E = A * A; // NOT OK!! temporary expression
		auto F = A + B + D ; // NOT OK!! temporary expression
		auto G = A * A.t(); // NOT OK!! temporary expression

		vec V = {0,1,2,3,4};

		for(auto&& i : V) // OK, no temporary exression
		{
		// do something
		}
		
		for(auto&& i : V+V) // NOT OK!! temporary expression
		{
		// do something
		}

		auto& S1 = spm.S(1); // OK and recommended
		const cx_mat& S2 = spm.S(2); // also OK  
		
	      </pre>
	    </li>


	    
	    <li><b>Does QIClib use C++14 features?</b><br>
	      No, only C++11 features have been used. 
	      C++14 features like <i>auto return type deductions for functions</i> have been avoided by using template meta-programming.
	      But users are requested to use latest C++14/17 features, which increase efficiency and usability.
	    </li>
	    
	
		<li><b>Does QIClib use multi-threaded algorithms for computations?</b><br>
			Yes and No. There are several ways to develop multi-threaded or parallel applications using QIClib. 
			<ul>
				<li> Using high performance multi-threaded <a href = "http://www.netlib.org/lapack/">LAPACK</a> and 
				  <a href = "http://www.netlib.org/blas">BLAS</a> replacements like <a href = "http://www.openblas.net/">OpenBLAS</a>, 
			  		<a href = "https://software.intel.com/en-us/intel-mkl">Intel MKL</a>, or 
			  		<a href = "http://developer.amd.com/tools-and-sdks/archive/amd-core-math-library-acml/"> AMD ACML</a>.</li>
				
				<li> Loop parallelization using <a href="http://www.openmp.org/">OpenMP</a> or others similar libraries. </li>
				
				<li> <a href="#TrX">TrX</a>, <a href="#Tx">Tx</a>, <a href="#sysperm">sysperm</a>, <a href="#apply">apply</a>, 
				<a href="#apply_ctrl">apply_ctrl</a>, <a href="#make_ctrl">make_ctrl</a>, <a href="#measure">measure</a>,
				and <a href="#measure_comp">measure_comp</a> have <i>optional</i> multi-threaded algorithms if 
				<a href="http://www.openmp.org/">OpenMP</a> is enabled in compiler argument, i.e., <code>-fopenmp</code> in 
				<a href="https://gcc.gnu.org/">gcc</a> or <a href = "http://clang.llvm.org/">clang</a>. For this, define
				<code>QICLIB_USE_OPENMP</code> macro before  before including <code>QIClib</code> header. One can individually enable
				multi-threading in those mentioned functions. For this, see  <a href="#macro">preprocessor macros in QIClib</a> for details.
				</ul>
		
			 <b>Note:</b> These three procedures of parallelization do not mix well. Use only one of the procedures. For best performance,
			 try to use only one of first two methods.</li>  

	  </ul>

	  <a href="#top">Go to top</a>


	  <hr><hr>
	  <a name="macro"></a>
	  <h3>Helper preprocessor macros</h3>
	  <hr> <br>
		QIClib can be configured by defining following macros before including <code>QIClib</code> header.
		
		<br><br>


		<table>
	      <tbody>

		<tr><td> QICLIB_MAXQDIT_COUNT </td><td>  </td><td> Maximum number of qudits that can be handled by QIClib.
		By default, it is 40.</td></tr>
		
		<tr><td> QICLIB_FLOAT_PRECISION </td><td>  </td><td> Precision for <code>float</code>. By default, it is
		<code>100.0 * std::numeric_limits&lt;float&gt;::epsilon()<code>.</td></tr>

		<tr><td> QICLIB_DOUBLE_PRECISION </td><td>  </td><td> Precision for <code>double</code>. By default, it is
		<code>100.0 * std::numeric_limits&lt;double&gt;::epsilon()<code>.</td></tr>

		<tr><td> QICLIB_NO_INIT_MESSAGE </td><td>  </td><td> Disable printing of messages by <code><a href="#init">Init</a></code>
		 class.</td></tr>

	
		<tr><td> QICLIB_NO_SPM </td><td>  </td><td> Disable instantiation of <code><a href="#spm">SPM</a></code>
		 class.</td></tr>		
		
		<tr><td> QICLIB_NO_GATES </td><td>  </td><td> Disable instantiation of <code><a href="#gates">GATES</a></code>
		 class.</td></tr>
		
		<tr><td> QICLIB_DONT_USE_NLOPT </td><td>  </td><td> QIClib will not use 
		<a href="http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a> dependent features.</td></tr>
		 
		 <tr><td>  QICLIB_USE_OLD_DISCORD </td><td>  </td><td> QIClib will use old discord syntaxes (before version 1.0.0).</td></tr>
				
		<tr><td>  QICLIB_USE_OPENMP </td><td>  </td><td> QIClib will use multi-threaded algorithms for 
		<a href="#TrX">TrX</a>, <a href="#Tx">Tx</a>, <a href="#sysperm">sysperm</a>, <a href="#apply">apply</a>, 
				<a href="#apply_ctrl">apply_ctrl</a>, <a href="#make_ctrl">make_ctrl</a>, <a href="#measure">measure</a>,
				and <a href="#measure_comp">measure_comp</a> if <a href="http://www.openmp.org/">OpenMP</a> is enabled.</td></tr>
		
	
		<tr><td>  QICLIB_USE_OPENMP_TRX </td><td>  </td><td> QIClib will use multi-threaded algorithm for 
		<a href="#TrX">TrX</a> if <a href="http://www.openmp.org/">OpenMP</a> is enabled.</td></tr>


		<tr><td>  QICLIB_USE_OPENMP_TX </td><td>  </td><td> QIClib will use multi-threaded algorithm for 
		<a href="#Tx">Tx</a> if <a href="http://www.openmp.org/">OpenMP</a> is enabled.</td></tr>

		<tr><td>  QICLIB_USE_OPENMP_SYSPERM </td><td>  </td><td> QIClib will use multi-threaded algorithm for 
		<a href="#sysperm">sysperm</a> if <a href="http://www.openmp.org/">OpenMP</a> is enabled.</td></tr>

		<tr><td>  QICLIB_USE_OPENMP_APPLY </td><td>  </td><td> QIClib will use multi-threaded algorithms for 
		<a href="#apply">apply</a> and 
				<a href="#apply_ctrl">apply_ctrl</a> if <a href="http://www.openmp.org/">OpenMP</a> is enabled.</td></tr>

		<tr><td>  QICLIB_USE_OPENMP_MAKE_CTRL </td><td>  </td><td> QIClib will use multi-threaded algorithm for 
		<a href="#make_ctrl">make_ctrl</a> if <a href="http://www.openmp.org/">OpenMP</a> is enabled.</td></tr>

	
		<tr><td>  QICLIB_USE_OPENMP_MEASURE </td><td>  </td><td> QIClib will use multi-threaded algorithms for 
		<a href="#measure">measure</a> and 
				<a href="#measure_comp">measure_comp</a> if <a href="http://www.openmp.org/">OpenMP</a> is enabled.</td></tr>



	      </tbody>
	    </table>
     <br>

	  <hr><hr>
	  <a name="api_additions"></a>
	  <h3>API Additions</h3>
	  <hr> <br>

		<b>Version 1.0</b><br><br>
	  <ul>
		<li>Bug fix in <code><a href="#tsallis_prob">tsallis_prob</a></code>.</li>
    	<li>Added <code><a href="#gram_schmidt">gram_schmidt</a></code>.</li>
    	<li>Added <code><a href="#dense_to_sparse">dense_to_sparse</a></code>, 
    		<code><a href="#sparse_to_dense">sparse_to_dense</a></code>.</li>
    	<li>Added <code><a href="#discord_space">discord_space</a></code>, <code><a href="#deficit_space">deficit_space</a></code>.</li>
    	<li>Added <code><a href="#is_Normal">is_Normal</a></code>.</li>
    	<li>Added <code><a href="#rel_entropy">rel_entropy</a></code>, <code><a href="#rel_entropy_prob">rel_entropy_prob</a></code>.</li>
		<li>Added coherence measures, <code><a href="#l1_coh">l1_coh</a></code> and 
			<code><a href="#rel_entropy_coh">rel_entropy_coh</a></code>.</li>
		<li>Added <code><a href="#schmidt">schmidt_full</a></code>.</li>
		<li>Added <a href="#macro">macro features</a> to fine tune the library behavior.</li>
		<li><code>std::runtime_error</code> exception for <code>eig_sym/eig_gen</code> decomposition.</li>
		<li><code>std::runtime_error</code> exception for <code>qr</code> decomposition.</li>
		<li>Added <code><a href="#randPerm">randPerm</a></code>.</li>
		<li>Added <code><a href="#make_ctrl">make_ctrl</a></code>.</li>
		<li>Default template parameter of <code><a href="#mket"mket></a></code>, <code><a href="#mproj">mproj</a></code> is now 
			<code>double</code>.</li>
		<li>Optional multi-threaded algorithm for <a href="#TrX">TrX</a>, <a href="#Tx">Tx</a>, <a href="#sysperm">sysperm</a>, <a href="#apply">apply</a>, 
				<a href="#apply_ctrl">apply_ctrl</a>, <a href="#make_ctrl">make_ctrl</a>, <a href="#measure">measure</a>,
				and <a href="#measure_comp">measure_comp</a>.</li>	  
	  
	  
	   </ul>
	




	  <b>Version 0.0.4</b><br><br>
	  <ul>
	    <li> Added <code><a href="#purify">purify</a></code>,  
	      <code><a href="#std_to_HS">std_to_HS</a></code>, and <code><a href="#HS_to_std">HS_to_std</a></code>.</li>
	    <li> Added <code><a href="#measure">measure</a></code> and <code><a href="#measure_comp">measure_comp</a></code>.</li>
	    <li> Added random number/matrix generators.</li>
	    <li> Added <code><a herf = "#is_diagonalizable">is_diagonalizable</a></code>.
	    <li> Faster <code><a href="#is_equal">is_equal</a></code>, <code><a href="#is_Hermitian">is_Hermitian</a></code>, 
	      <code><a href="#is_Unitary">is_Unitary</a></code>, 
	      <code><a href="#is_pure">is_pure</a></code>, <code><a href="#is_valid_state">is_valid_state</a></code>.
	    <li> Fixed a bug in <a href="#discord_func">discord like functions</a>.</li>
	  </ul>
	  <a href="#top">Go to top</a>

	  <hr><br>

	  <b>Version 0.0.3</b><br><br>
	  <ul>
	    <li> <code><a href="#dsum">dsum</code></a></code> and <code><a href="#dsum_pow">dsum_pow</a></code> added.</li>
<li> Fixed a bug in <code><a href="#tensor">tensor</a></code>.</li>
</ul>
<a href="#top">Go to top</a>

<hr><br>

<b>Version 0.0.2</b><br><br>
<ul>
  <li> <code><a href=#absm>absm</a></code> added.</li>
  <li> <code><a href=#schatten>schatten</a></code> added.</li>
</ul>
<a href="#top">Go to top</a>

<footer class="site-footer">
  <span class="site-footer-owner"><a href="https://github.com/titaschanda/QIClib">Quantum Information and Computation library (QIClib)</a> 
    is maintained by <a href="https://github.com/titaschanda">Titas Chanda</a>.</span>

  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the 
    <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
</footer>

</section>


</body>
</html>
